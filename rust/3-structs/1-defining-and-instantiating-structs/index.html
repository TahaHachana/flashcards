<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="noindex, nofollow">
  <title>Programming Syntax Flashcards - Rust - 3-Structs - 1-Defining-And-Instantiating-Structs</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
</head>

<body class="text-bg-dark">
  <div class="d-flex flex-column min-vh-100 min-vw-100">
    <div class="d-flex flex-grow-1 justify-content-center align-items-center">
      <div class="d-grid gap-2 col-12 mx-auto">
        
<div id="carousel" class="carousel slide">
    <div class="container">
        <div class="row">
            <!-- <div class="carousel-inner" style="width: 70%; margin-left: 15%;"> -->
            <div class="carousel-inner">

                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h1>Defining a Struct</h1>
<p>How do you define a struct in Rust?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Use the <code>struct</code> keyword, name the struct, and list its fields and types inside braces.</p>
<pre><code class="language-rust">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
</code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h1>Instantiating a Struct</h1>
<p>How do you create an instance of a struct, and does field order matter?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Provide <code>field: value</code> pairs inside braces after the struct name. Field order does not matter; Rust matches by field names, not position.</p>
<pre><code class="language-rust">let user1 = User {
    email: String::from(&quot;someone@example.com&quot;),
    username: String::from(&quot;someusername123&quot;),
    active: true,
    sign_in_count: 1,
};
</code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h1>Accessing and Mutating Fields</h1>
<p>How do you read and change struct fields?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Use dot notation. To change fields, the entire instance must be declared <code>mut</code>.</p>
<pre><code class="language-rust">let mut user1 = User {
    active: true,
    username: String::from(&quot;name&quot;),
    email: String::from(&quot;old@example.com&quot;),
    sign_in_count: 1,
};

user1.email = String::from(&quot;new@example.com&quot;);
println!(&quot;{}&quot;, user1.email);
</code></pre>
<p>Note: Individual fields can’t be marked <code>mut</code>; mutability is attached to the binding (<code>let mut user1</code>).</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h1>Field Init Shorthand</h1>
<p>What is the field init shorthand when constructing a struct?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>If variable (or parameter) names match field names, you can omit <code>field: field</code> and just write the identifier once. Rust automatically assigns the variable with the same name to that field.</p>
<pre><code class="language-rust">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        username,      // same as: username: username
        email,         // same as: email: email
        sign_in_count: 1,
    }
}

let user = build_user(String::from(&quot;a@example.com&quot;), String::from(&quot;alice&quot;));
</code></pre>
<p>Benefits:
- Reduces repetition and visual noise.
- Encourages field names that align with conceptual parameter names.
- Works only when the variable is in scope and has the exact same identifier as the field.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h1>Struct Update Syntax</h1>
<p>How do you create a new struct instance using fields from an existing one?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Use <code>..existing_instance</code> to fill in the remaining fields from another instance. This performs a field-by-field move (or copy for <code>Copy</code> types). Non-<code>Copy</code> fields (e.g. <code>String</code>) are moved, so you can no longer use them through the original instance afterward.</p>
<pre><code class="language-rust">#[derive(Debug)]
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

let user1 = User {
    active: true,
    username: String::from(&quot;alice&quot;),
    email: String::from(&quot;alice@example.com&quot;),
    sign_in_count: 1,
};

let user2 = User {
    email: String::from(&quot;new@example.com&quot;),
    ..user1
};

// user1.username and user1.email were moved; user1 cannot be fully reused.
// println!(&quot;{}&quot;, user1.username); // &lt;-- would be a compile error
println!(&quot;{:?}&quot;, user2);
</code></pre>
<p>Key points:
- You must specify at least one field before <code>..user1</code> (cannot be the only part).
- Order: explicitly set fields first, then <code>..source</code>.
- If all remaining fields are <code>Copy</code>, the original instance stays usable.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h1>Tuple Structs</h1>
<p>What are tuple structs and how are they defined and used?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Tuple structs are like named tuples: they give a distinct type name to a tuple without naming individual fields. They are useful for:
- Creating separate types that would otherwise share the same underlying field types (type safety)
- Lightweight wrappers (e.g., newtype-like patterns with multiple fields)
- Semantic clarity while keeping positional access</p>
<pre><code class="language-rust">// Defining two tuple structs with identical inner types:
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);

// They are different types; the following would not compile:
// let c: Color = origin; // type mismatch

// Access by pattern matching (destructuring):
let Point(x, y, z) = origin;
println!(&quot;origin coords = ({x}, {y}, {z})&quot;);

// Index-style access is NOT supported (e.g., origin.0 is valid but only because
// tuple struct fields are positional like tuple elements).
println!(&quot;Red component of black: {}&quot;, black.0);
</code></pre>
<p>Key points:
- Field positions (0,1,2,...) act like tuple indices.
- You cannot mix instances of different tuple struct types even if their field types match.
- Derive traits (e.g., Debug, Copy) just like with regular structs.
- Prefer a regular struct when field names improve readability; use tuple structs when names would be redundant (e.g., <code>struct Inches(u32);</code>).</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h1>Unit-Like Structs</h1>
<p>What is a unit-like struct and when would you use it?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>A unit-like struct is a struct with no fields. It behaves like the unit type <code>()</code> in terms of stored data (it occupies zero bytes) but has its own distinct type name. These are useful for:
- Marker / tag types (to convey intent or restrict APIs)
- Implementing traits where no data is required
- Phantom types (often combined with <code>PhantomData&lt;T&gt;</code>)
- Zero-cost abstractions (no runtime footprint)</p>
<pre><code class="language-rust">// Definition: no braces with fields — just the name and a semicolon.
struct AlwaysEqual;

// Use just by naming it (instantiation is trivial).
let subject = AlwaysEqual;

// Implement a trait even without data.
use std::fmt;
impl fmt::Display for AlwaysEqual {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;&lt;AlwaysEqual&gt;&quot;)
    }
}
println!(&quot;{}&quot;, subject);
</code></pre>
<p>Key points:
- Zero-sized type (ZST): the compiler may optimize away its storage.
- Distinct from the unit value <code>()</code>, even though both store no data.
- Great for signaling behavior or capability via the type system.
- Often appears in advanced patterns (stateless services, type-state encodings, trait impl anchors).</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
            </div>
        </div>
        <div class="row">
            <div class="col ms-3">
                <button class="btn btn-dark btn-lg btn-outline-light w-100" type="button" data-bs-target="#carousel"
                    data-bs-slide="prev">
                    <!-- <span class="carousel-control-prev-icon" aria-hidden="true"></span> -->
                    <span class="">Previous</span>
                </button>
            </div>
            <div class="col me-3">
                <button class="btn btn-dark btn-lg btn-outline-light w-100" type="button" data-bs-target="#carousel"
                    data-bs-slide="next">
                    <!-- <span class="carousel-control-next-icon" aria-hidden="true"></span> -->
                    <span class="">Next</span>
                </button>
            </div>
        </div>
    </div>
</div>
<style>
    .flip-card {
        background-color: transparent;
        /* width: 200px; */
        height: 300px;
        /* border: 1px solid #f1f1f1; */
        /* perspective: 1000px; */
        /* Remove this if you don't want the 3D effect */
    }

    /* This container is needed to position the front and back side */
    .flip-card-inner {
        position: relative;
        width: 100%;
        height: 100%;
        /* text-align: center; */
        transition: transform 0.8s;
        transform-style: preserve-3d;
    }

    /* Do an horizontal flip when you move the mouse over the flip box container */
    /* .flip-card:hover .flip-card-inner {
        transform: rotateY(180deg);
    } */

    /* Position the front and back side */
    .flip-card-front,
    .flip-card-back {
        position: absolute;
        width: 100%;
        height: 100%;
        -webkit-backface-visibility: hidden;
        /* Safari */
        backface-visibility: hidden;
    }

    /* Style the front side (fallback if image is missing) */
    /* .flip-card-front {
        background-color: #bbb;
        color: black;
    } */

    /* Style the back side */
    .flip-card-back {
        /* background-color: dodgerblue;
        color: white; */
        transform: rotateY(180deg);
    }

    .vertical-center {
        margin: 0;
        position: absolute;
        top: 50%;
        -ms-transform: translateY(-50%);
        transform: translateY(-50%);
    }

    pre {
        white-space: pre-wrap;
    }

    .card-body {
        overflow: auto;
    }
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script>
    document.querySelector(".carousel-item").classList.add("active")
    const myCarouselElement = document.querySelector('#carousel')
    const carousel = new bootstrap.Carousel(myCarouselElement, {
        touch: true
    });
</script>
<script>
    hljs.highlightAll();

    document.addEventListener('DOMContentLoaded', (event) => {
        const flipCards = document.querySelectorAll('.flip-card');

        flipCards.forEach(flipCard => {
            const flipCardInner = flipCard.querySelector('.flip-card-inner');
            let isFlipped = false;

            flipCard.addEventListener('click', () => {
                if (isFlipped) {
                    flipCardInner.style.transform = 'rotateY(0deg)';
                } else {
                    flipCardInner.style.transform = 'rotateY(180deg)';
                }
                isFlipped = !isFlipped;
            });
        });
    });
</script>

      </div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.min.js"
    integrity="sha384-0pUGZvbkm6XF6gxjEnlmuGrJXVbNuzT9qBBavbLwCsOGabYfZo0T0to5eqruptLy"
    crossorigin="anonymous"></script>
</body>

</html>