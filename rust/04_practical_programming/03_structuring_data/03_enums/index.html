<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="noindex, nofollow">
  <title>Flashcards - Rust - 04 Practical Programming - 03 Structuring Data - 03 Enums</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
</head>

<body class="text-bg-dark">
  <div class="d-flex flex-column min-vh-100 min-vw-100">
    <div class="d-flex flex-grow-1 justify-content-center align-items-center">
      <div class="d-grid gap-2 col-12 mx-auto">
        
<div id="carousel" class="carousel slide">
    <div class="container">
        <div class="row">
            <!-- <div class="carousel-inner" style="width: 70%; margin-left: 15%;"> -->
            <div class="carousel-inner">

                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>What Are Enums and Why Do They Exist?</h2>
<p>What is an enum in Rust and how is it more powerful than enums in languages like C or Java?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>An enum (enumeration) is a type that can be one of several variants, representing data that can be one thing OR another.</p>
<p><strong>Rust's power</strong>: Unlike C/Java enums, Rust enum variants can carry <strong>different types and amounts of data</strong>:</p>
<pre><code class="language-rust">// Simple enum (like C/Java)
enum TrafficLight {
    Red,
    Yellow,
    Green,
}

// Powerful Rust enum - variants hold data!
enum Message {
    Quit,                      // No data
    Move { x: i32, y: i32 },  // Named fields
    Write(String),             // Single value
    ChangeColor(u8, u8, u8),  // Multiple values
}
</code></pre>
<p>This makes Rust enums similar to "algebraic data types" or "tagged unions" in functional languages.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Enum Variant Namespace</h2>
<p>How do you access enum variants in Rust, and what syntax error happens if you forget the namespace?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Enum variants are <strong>namespaced under the enum name</strong>:</p>
<pre><code class="language-rust">enum Direction {
    North,
    South,
}

// WRONG
let dir = North;  // ERROR: can't find value `North`

// CORRECT
let dir = Direction::North;  // Must use EnumName::Variant
</code></pre>
<p><strong>Optional shortcut</strong> - bring variants into scope:</p>
<pre><code class="language-rust">use Direction::*;
let dir = North;  // Now OK
</code></pre>
<p>But use carefully to avoid naming conflicts. The <code>::</code> syntax makes the enum origin clear.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Three Variant Styles</h2>
<p>What are the three styles of enum variants in Rust, and what struct type does each resemble?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <ol>
<li><strong>Unit variants</strong> (no data) - like unit structs</li>
</ol>
<pre><code class="language-rust">enum Message {
    Quit,  // No associated data
}
</code></pre>
<ol>
<li><strong>Tuple variants</strong> - like tuple structs</li>
</ol>
<pre><code class="language-rust">enum Message {
    Write(String),              // One field
    ChangeColor(u8, u8, u8),   // Multiple fields
}
</code></pre>
<ol>
<li><strong>Struct variants</strong> - like classic structs</li>
</ol>
<pre><code class="language-rust">enum Message {
    Move { x: i32, y: i32 },  // Named fields
}
</code></pre>
<p>All three can coexist in the same enum, and each variant acts like its own constructor function.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Enums with Methods</h2>
<p>Can enums have methods like structs? Show an example with both associated functions and instance methods.</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p><strong>Yes</strong>, enums can have methods in impl blocks:</p>
<pre><code class="language-rust">enum Message {
    Quit,
    Write(String),
}

impl Message {
    // Associated function (constructor)
    fn new_write(text: &amp;str) -&gt; Self {
        Message::Write(String::from(text))
    }

    // Instance method
    fn call(&amp;self) {
        match self {
            Message::Quit =&gt; println!(&quot;Quitting&quot;),
            Message::Write(text) =&gt; println!(&quot;Writing: {}&quot;, text),
        }
    }

    // Method checking variant type
    fn is_quit(&amp;self) -&gt; bool {
        matches!(self, Message::Quit)
    }
}

// Usage
let msg = Message::new_write(&quot;hello&quot;);
msg.call();
</code></pre>
<p>Methods work identically to struct methods.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Enum Memory Layout</h2>
<p>How is an enum's size determined in memory, and what's the implication for variants with different sizes?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Enum size = <strong>largest variant's size + discriminant (tag)</strong></p>
<pre><code class="language-rust">enum Example {
    Small(u8),           // 1 byte
    Large([u8; 100]),    // 100 bytes
}
// Size of Example = 100+ bytes for ALL instances
</code></pre>
<p><strong>Implication</strong>: Even if you store <code>Example::Small</code>, it takes up 100+ bytes because the enum must be sized for its largest variant.</p>
<p><strong>Solution for large variants</strong>: Use <code>Box</code> to store large data on the heap:</p>
<pre><code class="language-rust">enum Example {
    Small(u8),
    Large(Box&lt;[u8; 100]&gt;),  // Now just a pointer
}
// Small variants now only take a few bytes
</code></pre>
<p>Avoid enums with vastly different-sized variants if you'll have many instances.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Option<T> Enum</h2>
<p>What is Option<T>, why does it exist in Rust, and what are three ways to extract its value safely?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p><strong>Definition</strong>:</p>
<pre><code class="language-rust">enum Option&lt;T&gt; {
    None,
    Some(T),
}
</code></pre>
<p><strong>Why it exists</strong>: Rust has no null. <code>Option</code> represents "might not have a value."</p>
<p><strong>Three safe extraction methods</strong>:</p>
<ol>
<li><strong>Pattern matching</strong>:</li>
</ol>
<pre><code class="language-rust">match maybe_value {
    Some(v) =&gt; println!(&quot;Got: {}&quot;, v),
    None =&gt; println!(&quot;Nothing&quot;),
}
</code></pre>
<ol>
<li><strong>unwrap_or</strong> (provide default):</li>
</ol>
<pre><code class="language-rust">let value = maybe_value.unwrap_or(0);
</code></pre>
<ol>
<li><strong>if let</strong>:</li>
</ol>
<pre><code class="language-rust">if let Some(v) = maybe_value {
    println!(&quot;Got: {}&quot;, v);
}
</code></pre>
<p>Avoid <code>unwrap()</code> and <code>expect()</code> in production - they panic on None.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Result<T, E> Enum</h2>
<p>What is Result<T, E>, when do you use it, and how does the ? operator work with it?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p><strong>Definition</strong>:</p>
<pre><code class="language-rust">enum Result&lt;T, E&gt; {
    Ok(T),     // Success value
    Err(E),    // Error value
}
</code></pre>
<p><strong>Use for</strong>: Functions that can fail, returning either success or error.</p>
<pre><code class="language-rust">fn divide(a: f64, b: f64) -&gt; Result&lt;f64, String&gt; {
    if b == 0.0 {
        Err(String::from(&quot;Division by zero&quot;))
    } else {
        Ok(a / b)
    }
}
</code></pre>
<p><strong>The ? operator</strong>: Early returns on error</p>
<pre><code class="language-rust">fn might_fail() -&gt; Result&lt;i32, String&gt; {
    let value = divide(10.0, 2.0)?;  // Returns Err if error
    Ok(value as i32)  // Continues if Ok
}
</code></pre>
<p>The <code>?</code> operator unwraps <code>Ok</code> or returns the <code>Err</code> early.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Making Impossible States Unrepresentable</h2>
<p>How do enums help make impossible states unrepresentable? Show a bad struct design and its enum solution.</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p><strong>Bad design with struct</strong> - allows invalid states:</p>
<pre><code class="language-rust">struct User {
    username: String,
    email: Option&lt;String&gt;,
    verified: bool,  // Problem: verified=true but email=None!
}
</code></pre>
<p><strong>Good design with enum</strong> - invalid states impossible:</p>
<pre><code class="language-rust">enum User {
    Unverified {
        username: String,
    },
    Verified {
        username: String,
        email: String,  // Always present for verified users
    },
}
</code></pre>
<p>The type system <strong>enforces</strong> that verified users have emails. The compiler won't let you create an invalid state.</p>
<p><strong>Principle</strong>: Use enums to model mutually exclusive states where each state has different associated data.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Accessing Enum Variant Data</h2>
<p>Why can't you directly access data in enum variants, and what's the correct way to do it?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p><strong>Can't use direct access</strong>:</p>
<pre><code class="language-rust">enum Message {
    Write(String),
}

let msg = Message::Write(String::from(&quot;hello&quot;));
// println!(&quot;{}&quot;, msg.0);  // ERROR: can't index into enum
</code></pre>
<p><strong>Must use pattern matching</strong>:</p>
<pre><code class="language-rust">match msg {
    Message::Write(text) =&gt; println!(&quot;{}&quot;, text),
    _ =&gt; {}
}

// Or if let
if let Message::Write(text) = msg {
    println!(&quot;{}&quot;, text);
}
</code></pre>
<p><strong>Why</strong>: The enum could be any variant. You must prove which variant it is through pattern matching before accessing its data. This ensures type safety.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Exhaustive Matching Requirement</h2>
<p>What happens if you don't handle all enum variants in a match expression?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p><strong>Compile error</strong> - Rust requires exhaustive matching:</p>
<pre><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
}

fn process(msg: Message) {
    match msg {
        Message::Quit =&gt; println!(&quot;Quit&quot;),
        Message::Write(text) =&gt; println!(&quot;{}&quot;, text),
        // ERROR: non-exhaustive patterns: `Move { .. }` not covered
    }
}
</code></pre>
<p><strong>Solutions</strong>:</p>
<ol>
<li>Handle all variants explicitly:</li>
</ol>
<pre><code class="language-rust">match msg {
    Message::Quit =&gt; {},
    Message::Move { x, y } =&gt; {},
    Message::Write(text) =&gt; {},
}
</code></pre>
<ol>
<li>Use catch-all pattern:</li>
</ol>
<pre><code class="language-rust">match msg {
    Message::Quit =&gt; {},
    _ =&gt; {}  // Handles remaining variants
}
</code></pre>
<p>This prevents forgetting to handle cases when you add new variants.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>C-Style Enums with Values</h2>
<p>How do you create C-style enums with explicit numeric values in Rust?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Assign explicit values to variants:</p>
<pre><code class="language-rust">enum HttpStatus {
    Ok = 200,
    NotFound = 404,
    InternalServerError = 500,
}

// Cast to integer
let code = HttpStatus::Ok as i32;  // 200
</code></pre>
<p><strong>Limitations</strong>:
- Can only use integer types
- Can't easily convert back from integer to enum (need custom implementation)
- Less common in Rust than data-carrying enums</p>
<p><strong>Use when</strong>: You need numeric constants with type safety, like HTTP status codes, error codes, or protocol values.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>State Machine Pattern with Enums</h2>
<p>Why are enums ideal for modeling state machines? Provide a simple example.</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Enums are perfect for state machines because:
- Each state is a variant
- Each state can carry relevant data
- Compiler ensures all states are handled
- Type system enforces valid transitions</p>
<pre><code class="language-rust">enum ConnectionState {
    Disconnected,
    Connecting,
    Connected { session_id: u64 },
    Error { reason: String },
}

struct Connection {
    state: ConnectionState,
}

impl Connection {
    fn connect(&amp;mut self) {
        match self.state {
            ConnectionState::Disconnected =&gt; {
                self.state = ConnectionState::Connecting;
            }
            _ =&gt; println!(&quot;Already connecting/connected&quot;),
        }
    }
}
</code></pre>
<p>Each state carries only the data relevant to that state.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Moving vs Borrowing in Pattern Matching</h2>
<p>What's the difference between matching on an enum directly vs matching on a reference to it?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p><strong>Matching directly</strong> - moves non-Copy data:</p>
<pre><code class="language-rust">let opt = Some(String::from(&quot;hello&quot;));

match opt {
    Some(s) =&gt; println!(&quot;{}&quot;, s),  // s takes ownership
    None =&gt; {},
}
// Can't use opt anymore - value moved
</code></pre>
<p><strong>Matching on reference</strong> - borrows data:</p>
<pre><code class="language-rust">let opt = Some(String::from(&quot;hello&quot;));

match &amp;opt {
    Some(s) =&gt; println!(&quot;{}&quot;, s),  // s is &amp;String
    None =&gt; {},
}
println!(&quot;{:?}&quot;, opt);  // Still valid - opt not moved
</code></pre>
<p><strong>Alternative using ref</strong>:</p>
<pre><code class="language-rust">match opt {
    Some(ref s) =&gt; println!(&quot;{}&quot;, s),  // ref creates reference
    None =&gt; {},
}
println!(&quot;{:?}&quot;, opt);  // Still valid
</code></pre>
<p>Use <code>&amp;opt</code> or <code>ref</code> to avoid moving values out of enums.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Type-Safe Identifiers with Enums</h2>
<p>How can you use single-variant enums to create type-safe identifiers?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Wrap primitive types in distinct enum types:</p>
<pre><code class="language-rust">enum UserId { Id(u64) }
enum ProductId { Id(u64) }
enum OrderId { Id(u64) }

fn get_user(id: UserId) -&gt; User { /* ... */ }
fn get_product(id: ProductId) -&gt; Product { /* ... */ }

let user_id = UserId::Id(42);
let product_id = ProductId::Id(42);

get_user(user_id);           // OK
// get_user(product_id);     // ERROR: type mismatch!
</code></pre>
<p><strong>Benefits</strong>:
- Prevents mixing up IDs
- Compile-time type safety
- Self-documenting code
- Zero runtime cost (compiler optimizes away the wrapper)</p>
<p>Even though all IDs are u64 internally, the type system treats them as different types.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Common Enum Patterns Summary</h2>
<p>What are five common use cases for enums in Rust?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <ol>
<li><strong>Optional values</strong>: <code>Option&lt;T&gt;</code> for nullable data</li>
<li>
<p>Replaces null with type-safe alternative</p>
</li>
<li>
<p><strong>Error handling</strong>: <code>Result&lt;T, E&gt;</code> for fallible operations</p>
</li>
<li>
<p>Forces explicit error handling</p>
</li>
<li>
<p><strong>State machines</strong>: Each variant represents a state</p>
</li>
<li>
<p>Compiler ensures all states handled</p>
</li>
<li>
<p><strong>Message types</strong>: Different message kinds with different data</p>
</li>
<li>
<p>Clean API for varied payloads</p>
</li>
<li>
<p><strong>Making invalid states unrepresentable</strong>:</p>
</li>
<li>Use type system to prevent logical errors</li>
<li>Different variants have appropriate data</li>
</ol>
<p><strong>Key principle</strong>: If data can be "one of several alternatives," use an enum. The compiler will ensure you handle all cases.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
            </div>
        </div>
        <div class="row">
            <div class="col ms-3">
                <button class="btn btn-dark btn-lg btn-outline-light w-100" type="button" data-bs-target="#carousel"
                    data-bs-slide="prev">
                    <!-- <span class="carousel-control-prev-icon" aria-hidden="true"></span> -->
                    <span class="">Previous</span>
                </button>
            </div>
            <div class="col me-3">
                <button class="btn btn-dark btn-lg btn-outline-light w-100" type="button" data-bs-target="#carousel"
                    data-bs-slide="next">
                    <!-- <span class="carousel-control-next-icon" aria-hidden="true"></span> -->
                    <span class="">Next</span>
                </button>
            </div>
        </div>
    </div>
</div>
<style>
    .flip-card {
        background-color: transparent;
        /* width: 200px; */
        height: 300px;
        /* border: 1px solid #f1f1f1; */
        /* perspective: 1000px; */
        /* Remove this if you don't want the 3D effect */
    }

    /* This container is needed to position the front and back side */
    .flip-card-inner {
        position: relative;
        width: 100%;
        height: 100%;
        /* text-align: center; */
        transition: transform 0.8s;
        transform-style: preserve-3d;
    }

    /* Do an horizontal flip when you move the mouse over the flip box container */
    /* .flip-card:hover .flip-card-inner {
        transform: rotateY(180deg);
    } */

    /* Position the front and back side */
    .flip-card-front,
    .flip-card-back {
        position: absolute;
        width: 100%;
        height: 100%;
        -webkit-backface-visibility: hidden;
        /* Safari */
        backface-visibility: hidden;
    }

    /* Style the front side (fallback if image is missing) */
    /* .flip-card-front {
        background-color: #bbb;
        color: black;
    } */

    /* Style the back side */
    .flip-card-back {
        /* background-color: dodgerblue;
        color: white; */
        transform: rotateY(180deg);
    }

    .vertical-center {
        margin: 0;
        position: absolute;
        top: 50%;
        -ms-transform: translateY(-50%);
        transform: translateY(-50%);
    }

    pre {
        white-space: pre-wrap;
    }

    .card-body {
        overflow: auto;
    }
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script>
    document.querySelector(".carousel-item").classList.add("active")
    const myCarouselElement = document.querySelector('#carousel')
    const carousel = new bootstrap.Carousel(myCarouselElement, {
        touch: true
    });
</script>
<script>
    hljs.highlightAll();

    document.addEventListener('DOMContentLoaded', (event) => {
        const flipCards = document.querySelectorAll('.flip-card');

        flipCards.forEach(flipCard => {
            const flipCardInner = flipCard.querySelector('.flip-card-inner');
            let isFlipped = false;

            flipCard.addEventListener('click', () => {
                if (isFlipped) {
                    flipCardInner.style.transform = 'rotateY(0deg)';
                } else {
                    flipCardInner.style.transform = 'rotateY(180deg)';
                }
                isFlipped = !isFlipped;
            });
        });
    });
</script>

      </div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.min.js"
    integrity="sha384-0pUGZvbkm6XF6gxjEnlmuGrJXVbNuzT9qBBavbLwCsOGabYfZo0T0to5eqruptLy"
    crossorigin="anonymous"></script>
</body>

</html>