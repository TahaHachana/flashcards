<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="noindex, nofollow">
  <title>Flashcards - Rust - 04 Practical Programming - 01 Strings - 03 Utf-8</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
</head>

<body class="text-bg-dark">
  <div class="d-flex flex-column min-vh-100 min-vw-100">
    <div class="d-flex flex-grow-1 justify-content-center align-items-center">
      <div class="d-grid gap-2 col-12 mx-auto">
        
<div id="carousel" class="carousel slide">
    <div class="container">
        <div class="row">
            <!-- <div class="carousel-inner" style="width: 70%; margin-left: 15%;"> -->
            <div class="carousel-inner">

                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Why Direct String Indexing Fails in Rust</h2>
<p>Why doesn't direct string indexing work in Rust?</p>
<pre><code class="language-rust">let s = String::from(&quot;hello&quot;);
let first = s[0];  // Error
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>UTF-8 characters can be 1-4 bytes, making s[0] ambiguous. Should it return the first byte (might be middle of a character) or the first character (requires scanning)? Neither option is clearly correct. Rust prevents this ambiguity by not allowing direct indexing.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>What is UTF-8 Encoding</h2>
<p>What is UTF-8 and what are its key characteristics?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>UTF-8 is a variable-width character encoding with these properties:
- Variable-width: Characters can be 1, 2, 3, or 4 bytes
- Backward compatible: ASCII characters (0-127) are exactly 1 byte, same as ASCII
- Efficient: Common characters use fewer bytes
- Universal: Can represent all Unicode characters (over 1 million)</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>UTF-8 Byte Lengths by Character Type</h2>
<p>How many bytes do different character types use in UTF-8? Give examples for each category.</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>1 byte (ASCII): English letters (a-z), digits (0-9), common punctuation
2 bytes: Extended Latin (√©, √±), Greek (Œ±, Œ≤), Cyrillic, Hebrew, Arabic
3 bytes: Chinese (‰∏≠, Êñá), Japanese (Êó•, Êú¨), Korean (Ìïú, Í∏Ä)
4 bytes: Emoji (üòÄ, ü¶Ä, ‚ù§Ô∏è), less common symbols, historic scripts</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Chars vs Bytes Count Examples</h2>
<p>What are the character counts and byte counts for these strings?</p>
<pre><code class="language-rust">&quot;hello&quot;
&quot;se√±or&quot;
&quot;‰Ω†Â•Ω&quot;
&quot;üòÄü¶Ä&quot;
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>"hello": 5 chars, 5 bytes (ASCII, 1 byte each)
"se√±or": 5 chars, 6 bytes (√± is 2 bytes)
"‰Ω†Â•Ω": 2 chars, 6 bytes (3 bytes each)
"üòÄü¶Ä": 2 chars, 8 bytes (4 bytes each emoji)</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Visualizing UTF-8 Storage</h2>
<p>How is "caf√©" stored in memory as UTF-8 bytes?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <pre><code class="language-rust">let s = String::from(&quot;caf√©&quot;);
// Memory: [0x63, 0x61, 0x66, 0xC3, 0xA9]
//          'c'   'a'   'f'   '√©' (2 bytes)
</code></pre>
<p>The string has 4 characters but 5 bytes because '√©' requires 2 bytes (0xC3 0xA9). This shows why byte position ‚â† character position.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Problem - Ambiguous Indexing Meaning</h2>
<p>What would s[0] mean for this string and why is it ambiguous?</p>
<pre><code class="language-rust">let s = String::from(&quot;‰Ω†Â•Ω&quot;);  // 2 chars, 6 bytes
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Option A: First byte? Would be 0xE4 (part of '‰Ω†', invalid on its own)
Option B: First character? Would be '‰Ω†' (requires scanning all previous bytes)</p>
<p>Neither option is clearly correct. Users might expect different things, so Rust doesn't allow this ambiguous operation.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Problem - Invalid UTF-8 from Indexing</h2>
<p>Why would byte-based indexing break Rust's UTF-8 guarantee?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <pre><code class="language-rust">let s = String::from(&quot;‰Ω†Â•Ω&quot;);
// If s[0] returned first byte (0xE4)...
// That's not a complete character! Invalid UTF-8.
</code></pre>
<p>Returning a byte could produce invalid UTF-8 since multi-byte characters would be split. Rust guarantees strings are always valid UTF-8, so byte indexing would break this guarantee.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Problem - Performance Expectations</h2>
<p>Why would allowing string indexing create false performance expectations?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>In most languages, string indexing is O(1) constant time. In UTF-8, getting the Nth character requires scanning from the start - O(n) time:</p>
<pre><code class="language-rust">let ch = s[100];  // Would need to scan first 100 characters!
</code></pre>
<p>Users might assume indexing is fast when it's actually slow. Rust makes the cost explicit by requiring chars().nth(n).</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Problem - Slicing Dangers</h2>
<p>Why is slicing at arbitrary byte positions dangerous?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <pre><code class="language-rust">let s = String::from(&quot;‰Ω†Â•Ω&quot;);
// If allowed: &amp;s[0..1]
// Would slice in middle of '‰Ω†' - invalid UTF-8!
</code></pre>
<p>Slicing could split multi-byte characters, creating invalid UTF-8. Rust only allows slicing at valid character boundaries to maintain UTF-8 validity.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>What len Returns</h2>
<p>What does the len() method return for strings and why is this important to remember?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <pre><code class="language-rust">let s = String::from(&quot;‰Ω†Â•Ω&quot;);
println!(&quot;{}&quot;, s.len());  // 6 (bytes, not characters)
</code></pre>
<p>len() returns the byte count, NOT the character count. This is crucial because multi-byte characters make byte count different from character count. Use chars().count() for character count.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Accessing Characters with chars</h2>
<p>How do you access the first, nth, or iterate over characters in a string?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <pre><code class="language-rust">let s = String::from(&quot;hello&quot;);

// First character
let first = s.chars().next();  // Some('h')

// Nth character (0-indexed)
let third = s.chars().nth(2);  // Some('l')

// Iterate over all characters
for ch in s.chars() {
    println!(&quot;{}&quot;, ch);
}
</code></pre>
<p>Note: nth() is O(n) because it must scan previous characters.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Accessing Bytes with bytes</h2>
<p>How do you access raw bytes in a string and when should you use this?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <pre><code class="language-rust">let s = String::from(&quot;hello&quot;);
for byte in s.bytes() {
    println!(&quot;{}&quot;, byte);  // 104, 101, 108, 108, 111
}
</code></pre>
<p>Use bytes() for binary data or low-level processing where you need the raw UTF-8 bytes rather than characters. Each iteration gives you a u8.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Slicing at Valid UTF-8 Boundaries</h2>
<p>Why do these slices succeed or fail?</p>
<pre><code class="language-rust">let s = String::from(&quot;‰Ω†Â•Ω&quot;);
let slice1 = &amp;s[0..3];
let slice2 = &amp;s[0..1];
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>&amp;s[0..3] succeeds: Creates "‰Ω†" (one complete 3-byte character)
&amp;s[0..1] panics: Not on character boundary - would split the character '‰Ω†'</p>
<p>Slice points must be at character boundaries (the start of a character), never in the middle of a multi-byte character.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Character Boundaries Example</h2>
<p>For the string "caf√©", what are the valid slice boundaries and why?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <pre><code class="language-rust">let s = String::from(&quot;caf√©&quot;);
// Byte positions: 0  1  2  3  4  5
// Characters:     c  a  f  √© (2 bytes)
// Valid slices:   ^  ^  ^  ^     ^

&amp;s[0..1]  // ‚úÖ &quot;c&quot;
&amp;s[0..3]  // ‚úÖ &quot;caf&quot;
&amp;s[0..4]  // ‚ùå Panics: middle of '√©'
&amp;s[0..5]  // ‚úÖ &quot;caf√©&quot;
</code></pre>
<p>Position 4 is invalid because it's in the middle of the 2-byte character '√©'.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Finding Boundaries with char_indices</h2>
<p>What does char_indices() return and how does it help find valid boundaries?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <pre><code class="language-rust">let s = String::from(&quot;caf√©&quot;);
let indices: Vec&lt;usize&gt; = s.char_indices()
    .map(|(i, _)| i)
    .collect();
println!(&quot;{:?}&quot;, indices);  // [0, 1, 2, 3, 5]
</code></pre>
<p>char_indices() returns (byte_index, char) tuples. Notice no index 4 - it would be in the middle of '√©'. These indices are all valid slice boundaries.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Using char_indices for Position and Character</h2>
<p>What does this code print and what information does char_indices() provide?</p>
<pre><code class="language-rust">let s = String::from(&quot;‰Ω†Â•Ω‰∏ñÁïå&quot;);
for (index, ch) in s.char_indices() {
    println!(&quot;Byte {} starts character '{}'&quot;, index, ch);
}
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <pre><code>Byte 0 starts character '‰Ω†'
Byte 3 starts character 'Â•Ω'
Byte 6 starts character '‰∏ñ'
Byte 9 starts character 'Áïå'
</code></pre>
<p>char_indices() provides both the byte index where each character starts AND the character itself. Useful for finding valid slice positions.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Counting Characters vs Bytes</h2>
<p>How do you correctly count both bytes and characters in a string?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <pre><code class="language-rust">let s = String::from(&quot;Hello, ‰∏ñÁïå!&quot;);

// Byte count (O(1))
println!(&quot;Bytes: {}&quot;, s.len());  // 14

// Character count (O(n))
println!(&quot;Chars: {}&quot;, s.chars().count());  // 9
</code></pre>
<p>Always distinguish: len() for bytes (fast), chars().count() for characters (requires scanning).</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Getting the Nth Character</h2>
<p>How do you get the nth character from a string and what is its time complexity?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <pre><code class="language-rust">fn get_char_at(s: &amp;str, n: usize) -&gt; Option&lt;char&gt; {
    s.chars().nth(n)
}

let s = String::from(&quot;‰Ω†Â•Ω‰∏ñÁïå&quot;);
println!(&quot;{:?}&quot;, get_char_at(&amp;s, 0));  // Some('‰Ω†')
println!(&quot;{:?}&quot;, get_char_at(&amp;s, 2));  // Some('‰∏ñ')
</code></pre>
<p>Time complexity: O(n), not O(1) like array indexing, because it must scan through previous characters.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Safe Slicing by Character Position</h2>
<p>Why is this safe_slice function necessary and what does it do?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <pre><code class="language-rust">fn safe_slice(s: &amp;str, start: usize, end: usize) -&gt; Option&lt;&amp;str&gt; {
    let indices: Vec&lt;_&gt; = s.char_indices().map(|(i, _)| i).collect();

    if start &gt;= indices.len() || end &gt; indices.len() {
        return None;
    }

    let start_byte = indices[start];
    let end_byte = if end &lt; indices.len() {
        indices[end]
    } else {
        s.len()
    };

    Some(&amp;s[start_byte..end_byte])
}
</code></pre>
<p>Converts character positions to byte positions using char_indices(), ensuring slices are always at valid UTF-8 boundaries. Prevents panics from invalid slicing.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Character Position to Byte Position</h2>
<p>How do you convert a character position to its corresponding byte position?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <pre><code class="language-rust">fn char_pos_to_byte_pos(s: &amp;str, char_pos: usize) -&gt; Option&lt;usize&gt; {
    s.char_indices().nth(char_pos).map(|(i, _)| i)
}

let s = String::from(&quot;‰Ω†Â•Ω‰∏ñÁïå&quot;);
let byte_pos = char_pos_to_byte_pos(&amp;s, 2);
println!(&quot;{:?}&quot;, byte_pos);  // Some(6)
</code></pre>
<p>Use char_indices().nth(n) to get the byte index where the nth character starts.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Iterate with Byte Positions</h2>
<p>How do you iterate over characters while also getting their byte positions?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <pre><code class="language-rust">let s = String::from(&quot;Hello, ‰∏ñÁïå!&quot;);

for (byte_pos, ch) in s.char_indices() {
    println!(&quot;Character '{}' at byte {}&quot;, ch, byte_pos);
}
</code></pre>
<p>char_indices() gives you (byte_position, character) tuples, useful when you need to know where each character starts in the byte array.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Check if String is ASCII-only</h2>
<p>How do you check if a string contains only ASCII characters?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <pre><code class="language-rust">// Built-in method
fn is_ascii(s: &amp;str) -&gt; bool {
    s.is_ascii()
}

// Manual implementation
fn is_ascii_manual(s: &amp;str) -&gt; bool {
    s.chars().all(|c| c.is_ascii())
}

println!(&quot;{}&quot;, is_ascii(&quot;hello&quot;));  // true
println!(&quot;{}&quot;, is_ascii(&quot;‰Ω†Â•Ω&quot;));   // false
</code></pre>
<p>ASCII-only strings have byte count equal to character count.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Take First N Characters</h2>
<p>How do you extract the first n characters from a string?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <pre><code class="language-rust">fn take_chars(s: &amp;str, n: usize) -&gt; String {
    s.chars().take(n).collect()
}

let s = &quot;‰Ω†Â•Ω‰∏ñÁïå&quot;;
println!(&quot;{}&quot;, take_chars(s, 2));  // &quot;‰Ω†Â•Ω&quot;
</code></pre>
<p>Use chars().take(n).collect() to safely get first n characters regardless of byte lengths.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Reverse String with UTF-8</h2>
<p>How do you reverse a string while correctly handling multi-byte characters?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <pre><code class="language-rust">fn reverse_string(s: &amp;str) -&gt; String {
    s.chars().rev().collect()
}

let s = &quot;hello&quot;;
println!(&quot;{}&quot;, reverse_string(s));  // &quot;olleh&quot;

let s = &quot;‰Ω†Â•Ω&quot;;
println!(&quot;{}&quot;, reverse_string(s));  // &quot;Â•Ω‰Ω†&quot;
</code></pre>
<p>chars().rev() reverses character by character, maintaining UTF-8 validity.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Linear Time for Character Access</h2>
<p>What is the time complexity of getting the nth character and what's the workaround for faster access?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <pre><code class="language-rust">// O(n) - must scan 999 characters
let ch = s.chars().nth(999);

// Workaround: collect into Vec for O(1) access
let s = String::from(&quot;‰Ω†Â•Ω‰∏ñÁïå&quot;);
let chars: Vec&lt;char&gt; = s.chars().collect();
let ch = chars[2];  // O(1) access: '‰∏ñ'
</code></pre>
<p>Trade-off: Vec<char> uses more memory (4 bytes per character) but provides O(1) random access.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Fast Byte Operations</h2>
<p>Which string operations are O(1) constant time?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <pre><code class="language-rust">s.len()      // O(1) - just returns length field
s.is_empty() // O(1) - checks if length is 0
&amp;s[0..10]    // O(1) - if boundaries are valid
</code></pre>
<p>Byte-level operations are constant time because they don't require scanning or validation - they work directly with the byte array.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Slow Character Operations</h2>
<p>Which string operations are O(n) linear time and why?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <pre><code class="language-rust">s.chars().count()    // O(n) - must scan entire string
s.chars().nth(10)    // O(n) - must scan first 10 chars
</code></pre>
<p>Character operations require validation and scanning because UTF-8 is variable-width. Each character must be decoded to find character boundaries.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>UTF-8 Space Efficiency</h2>
<p>Why is UTF-8 space-efficient compared to UTF-16 and UTF-32?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>UTF-8: 1-4 bytes per character
- ASCII: 1 byte (same as pure ASCII)
- Common languages: 2-3 bytes
- Rare characters: 4 bytes</p>
<p>UTF-16: 2-4 bytes per character (wastes space for ASCII)
UTF-32: Always 4 bytes per character (very wasteful)</p>
<p>For most text (especially English and European languages), UTF-8 is significantly smaller.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>UTF-8 Backward Compatibility</h2>
<p>How is UTF-8 backward compatible with ASCII?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>UTF-8 ASCII characters (0-127) have the exact same byte values as ASCII encoding. This means:
- Pure ASCII text is valid UTF-8
- Old tools expecting ASCII work with UTF-8 strings containing only ASCII
- No conversion needed for ASCII-only text</p>
<p>This is a huge practical advantage for compatibility with legacy systems.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>UTF-8 Self-Synchronizing Property</h2>
<p>What does it mean that UTF-8 is self-synchronizing?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>If you jump to a random position in UTF-8 data, you can quickly find the next character boundary by looking at the byte's high bits. The encoding structure allows you to determine if a byte is:
- A single-byte character (starts with 0)
- The start of a multi-byte character (starts with 11)
- A continuation byte (starts with 10)</p>
<p>This makes error recovery and random access easier.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>UTF-8 No Endianness Issues</h2>
<p>Why does UTF-8 avoid endianness problems that UTF-16 and UTF-32 have?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>UTF-8 is byte-oriented, not word-oriented. Each character is a sequence of individual bytes, not multi-byte units that could be arranged in different orders (big-endian vs little-endian). Files can be transferred between systems without conversion or byte-order marks.</p>
<p>UTF-16 and UTF-32 use 16-bit and 32-bit units, which can be stored in different byte orders.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Mistake - Assuming len is Character Count</h2>
<p>What's wrong with this assumption and how do you fix it?</p>
<pre><code class="language-rust">let s = String::from(&quot;‰Ω†Â•Ω&quot;);
println!(&quot;{}&quot;, s.len());  // Assuming this is character count
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <pre><code class="language-rust">let s = String::from(&quot;‰Ω†Â•Ω&quot;);
println!(&quot;{}&quot;, s.len());  // 6 bytes, not 2 characters!

// For character count:
println!(&quot;{}&quot;, s.chars().count());  // 2 characters
</code></pre>
<p>len() returns bytes, not characters. Always use chars().count() for character count.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Mistake - Direct Indexing Attempt</h2>
<p>Why does this fail and what's the correct approach?</p>
<pre><code class="language-rust">let s = String::from(&quot;hello&quot;);
let ch = s[0];
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <pre><code class="language-rust">// ‚ùå Error: cannot index into a string
let ch = s[0];

// ‚úÖ Correct: use chars()
let ch = s.chars().next();      // Some('h')
let ch = s.chars().nth(0);      // Some('h')
</code></pre>
<p>Strings don't support direct indexing due to UTF-8's variable-width encoding. Use chars() to access characters.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Mistake - Slicing Without Checking Boundaries</h2>
<p>Why does this panic and how do you slice safely?</p>
<pre><code class="language-rust">let s = String::from(&quot;‰Ω†Â•Ω&quot;);
let slice = &amp;s[0..1];
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <pre><code class="language-rust">// ‚ùå Panics: not on character boundary
let slice = &amp;s[0..1];

// ‚úÖ Correct: slice at valid boundaries
let slice = &amp;s[0..3];  // &quot;‰Ω†&quot; (complete 3-byte char)

// Or use char_indices to find boundaries
for (i, _) in s.char_indices() {
    println!(&quot;Valid boundary: {}&quot;, i);
}
</code></pre>
<p>Must slice at character boundaries, not arbitrary byte positions.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Mistake - Comparing String Lengths</h2>
<p>What's wrong with this comparison?</p>
<pre><code class="language-rust">let s1 = String::from(&quot;hello&quot;);
let s2 = String::from(&quot;‰Ω†Â•Ω&quot;);
if s1.len() &gt; s2.len() {
    println!(&quot;s1 has more characters&quot;);
}
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <pre><code class="language-rust">// ‚ùå Wrong: s1 has 5 bytes, s2 has 6 bytes
// But s1 has 5 chars, s2 has 2 chars
if s1.len() &gt; s2.len() {
    println!(&quot;s1 has more characters&quot;);
}

// ‚úÖ Correct: compare character counts
if s1.chars().count() &gt; s2.chars().count() {
    println!(&quot;s1 has more characters&quot;);
}
</code></pre>
<p>len() compares bytes, not characters. Use chars().count() for character comparison.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Count Specific Character Pattern</h2>
<p>How do you count occurrences of a specific character in a string?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <pre><code class="language-rust">fn count_char(s: &amp;str, target: char) -&gt; usize {
    s.chars().filter(|&amp;c| c == target).count()
}

let s = &quot;hello world&quot;;
println!(&quot;{}&quot;, count_char(s, 'l'));  // 3
</code></pre>
<p>Use chars() to iterate, filter() to keep matching characters, count() to get the total.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Why UTF-8 Despite Complexity</h2>
<p>What are the four major advantages of UTF-8 that justify its indexing complexity?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <ol>
<li>Space efficient: ASCII uses 1 byte, common languages 2-3 bytes (smaller than UTF-16/32)</li>
<li>Backward compatible: ASCII text is valid UTF-8 with same byte values</li>
<li>No endianness issues: Byte-oriented, no byte-order concerns</li>
<li>Self-synchronizing: Can find character boundaries from any position</li>
</ol>
<p>These advantages make UTF-8 the dominant text encoding despite the indexing complexity.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>UTF-8 Variable Width Summary</h2>
<p>What does "variable-width encoding" mean and what's its main consequence for string operations?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Variable-width means characters can be different byte sizes (1-4 bytes in UTF-8). Main consequence: byte position ‚â† character position.</p>
<p>This makes:
- Direct indexing impossible (which byte/char?)
- Character access O(n) instead of O(1) (must scan)
- Slicing require boundary checks (can't split characters)
- len() return bytes, not characters (ambiguous otherwise)</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>When to Use Vec char for Performance</h2>
<p>When should you convert a String to Vec<char> and what's the trade-off?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <pre><code class="language-rust">let s = String::from(&quot;‰Ω†Â•Ω‰∏ñÁïå&quot;);
let chars: Vec&lt;char&gt; = s.chars().collect();

// Now O(1) random access
let ch = chars[2];  // '‰∏ñ'
</code></pre>
<p>Use when: You need frequent random character access (nth character multiple times)</p>
<p>Trade-off: 
- Pro: O(1) access instead of O(n)
- Con: Uses more memory (4 bytes per character in Vec vs variable 1-4 bytes in String)</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>UTF-8 Core Problem Summary</h2>
<p>Summarize the four problems that prevent direct string indexing in Rust.</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <ol>
<li>Ambiguous meaning: Should s[0] be first byte or first character?</li>
<li>Invalid UTF-8: Byte indexing could split multi-byte characters</li>
<li>Performance expectations: Users expect O(1), but UTF-8 character access is O(n)</li>
<li>Slicing dangers: Arbitrary byte positions could create invalid UTF-8</li>
</ol>
<p>Solution: Rust requires explicit use of chars() or bytes() to make intentions and costs clear.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
            </div>
        </div>
        <div class="row">
            <div class="col ms-3">
                <button class="btn btn-dark btn-lg btn-outline-light w-100" type="button" data-bs-target="#carousel"
                    data-bs-slide="prev">
                    <!-- <span class="carousel-control-prev-icon" aria-hidden="true"></span> -->
                    <span class="">Previous</span>
                </button>
            </div>
            <div class="col me-3">
                <button class="btn btn-dark btn-lg btn-outline-light w-100" type="button" data-bs-target="#carousel"
                    data-bs-slide="next">
                    <!-- <span class="carousel-control-next-icon" aria-hidden="true"></span> -->
                    <span class="">Next</span>
                </button>
            </div>
        </div>
    </div>
</div>
<style>
    .flip-card {
        background-color: transparent;
        /* width: 200px; */
        height: 300px;
        /* border: 1px solid #f1f1f1; */
        /* perspective: 1000px; */
        /* Remove this if you don't want the 3D effect */
    }

    /* This container is needed to position the front and back side */
    .flip-card-inner {
        position: relative;
        width: 100%;
        height: 100%;
        /* text-align: center; */
        transition: transform 0.8s;
        transform-style: preserve-3d;
    }

    /* Do an horizontal flip when you move the mouse over the flip box container */
    /* .flip-card:hover .flip-card-inner {
        transform: rotateY(180deg);
    } */

    /* Position the front and back side */
    .flip-card-front,
    .flip-card-back {
        position: absolute;
        width: 100%;
        height: 100%;
        -webkit-backface-visibility: hidden;
        /* Safari */
        backface-visibility: hidden;
    }

    /* Style the front side (fallback if image is missing) */
    /* .flip-card-front {
        background-color: #bbb;
        color: black;
    } */

    /* Style the back side */
    .flip-card-back {
        /* background-color: dodgerblue;
        color: white; */
        transform: rotateY(180deg);
    }

    .vertical-center {
        margin: 0;
        position: absolute;
        top: 50%;
        -ms-transform: translateY(-50%);
        transform: translateY(-50%);
    }

    pre {
        white-space: pre-wrap;
    }

    .card-body {
        overflow: auto;
    }
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script>
    document.querySelector(".carousel-item").classList.add("active")
    const myCarouselElement = document.querySelector('#carousel')
    const carousel = new bootstrap.Carousel(myCarouselElement, {
        touch: true
    });
</script>
<script>
    hljs.highlightAll();

    document.addEventListener('DOMContentLoaded', (event) => {
        const flipCards = document.querySelectorAll('.flip-card');

        flipCards.forEach(flipCard => {
            const flipCardInner = flipCard.querySelector('.flip-card-inner');
            let isFlipped = false;

            flipCard.addEventListener('click', () => {
                if (isFlipped) {
                    flipCardInner.style.transform = 'rotateY(0deg)';
                } else {
                    flipCardInner.style.transform = 'rotateY(180deg)';
                }
                isFlipped = !isFlipped;
            });
        });
    });
</script>

      </div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.min.js"
    integrity="sha384-0pUGZvbkm6XF6gxjEnlmuGrJXVbNuzT9qBBavbLwCsOGabYfZo0T0to5eqruptLy"
    crossorigin="anonymous"></script>
</body>

</html>