<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="noindex, nofollow">
  <title>Flashcards - Rust - 06-Intermediate-Rust - 01-Ownership And Lifetimes - 02-Common-Lifetime-Patterns</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
</head>

<body class="text-bg-dark">
  <div class="d-flex flex-column min-vh-100 min-vw-100">
    <div class="d-flex flex-grow-1 justify-content-center align-items-center">
      <div class="d-grid gap-2 col-12 mx-auto">
        
<div id="carousel" class="carousel slide">
    <div class="container">
        <div class="row">
            <!-- <div class="carousel-inner" style="width: 70%; margin-left: 15%;"> -->
            <div class="carousel-inner">

                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>What Are Lifetime Patterns?</h2>
<p>What are lifetime patterns in Rust, and why are they important for learning?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Lifetime patterns are recurring ways that lifetimes appear in real Rust code. They help you: (1) recognize common scenarios quickly, (2) write correct lifetime annotations naturally, (3) understand library code at a glance, and (4) diagnose lifetime errors faster. Instead of reasoning from first principles every time, you can pattern-match against common cases.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Pattern 1 Input-Output Flow Single Source</h2>
<p>What characterizes the "Input-Output Flow (Single Source)" pattern, and when should you use it?</p>
<pre><code class="language-rust">fn first_element&lt;'a&gt;(data: &amp;'a [i32]) -&gt; &amp;'a i32 {
    &amp;data[0]
}
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Characteristics: One reference input with lifetime <code>'a</code>, return type has same lifetime <code>'a</code>, other inputs (if any) have independent lifetimes or are values. Use when output is clearly extracted from one specific input. Mental shortcut: "Output points into input" → same lifetime.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Pattern 2 Multiple Sources Same Lifetime</h2>
<p>When should you use the same lifetime <code>'a</code> for multiple inputs and the return value?</p>
<pre><code class="language-rust">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() { x } else { y }
}
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Use this pattern when the return could come from any of multiple inputs, so all must live at least as long as the return value. The compiler enforces that all inputs must live at least as long as <code>'a</code>. Mental shortcut: "Output could be any input" → all same lifetime. This is more restrictive than Pattern 1, so use Pattern 1 if possible.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Pattern 3 Method Patterns Self Reference</h2>
<p>What are the key characteristics of method patterns that return references to <code>self</code> or data owned by <code>self</code>?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Methods with <code>&amp;self</code> or <code>&amp;mut self</code> as receiver that return references with lifetime tied to <code>self</code>'s lifetime. Often no explicit lifetime annotations needed due to elision. Used for: getters/accessors, builder/fluent APIs (returning <code>&amp;mut Self</code>), and iterator-like methods. Mental shortcut: "Method returns part of self" → implicit lifetime connection.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Pattern 4 Multiple Independent Lifetimes</h2>
<p>When should you use different lifetime parameters (<code>'a</code> and <code>'b</code>) for different inputs?</p>
<pre><code class="language-rust">fn search_with_default&lt;'a, 'b&gt;(
    data: &amp;'a [i32],
    target: i32,
    default: &amp;'b i32
) -&gt; &amp;'a i32
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Use different lifetimes when the return depends on only one input, or when inputs have independent validity requirements. This is more flexible for callers than requiring all inputs to have the same lifetime. Mental shortcut: "Some inputs are side channels" → separate lifetimes. Use when some inputs are only used during the function call, not returned.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Pattern 5 No Output References</h2>
<p>What lifetime considerations apply when a function uses references but doesn't return any references?</p>
<pre><code class="language-rust">fn compare&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; bool {
    x.len() &gt; y.len()
}
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>When return type doesn't contain references (or is <code>()</code>), input lifetimes are often independent and usually don't matter. The function only uses inputs temporarily during the call. Mental shortcut: "No references out" → lifetimes usually don't need to be related (and are often elided automatically).</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Pattern 6 Struct Methods With Lifetime Parameters</h2>
<p>How do methods work on structs that already have lifetime parameters?</p>
<pre><code class="language-rust">struct Parser&lt;'a&gt; {
    input: &amp;'a str,
    position: usize,
}

impl&lt;'a&gt; Parser&lt;'a&gt; {
    fn current_token(&amp;self) -&gt; &amp;'a str {
        &amp;self.input[self.position..self.position+5]
    }
}
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>The struct has lifetime parameter <code>'a</code>, and methods can return references with that lifetime. Methods can also introduce additional lifetimes (<code>'b</code>) for method-specific references. Methods inherit the struct's lifetime for returning references to internal data. Mental shortcut: "Struct owns the lifetime" → methods inherit it.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Pattern 7 Higher-Order Functions</h2>
<p>How do lifetimes work with higher-order functions that take closures or function pointers?</p>
<pre><code class="language-rust">fn apply_filter&lt;'a, F&gt;(data: &amp;'a [i32], predicate: F) -&gt; Vec&lt;&amp;'a i32&gt;
where
    F: Fn(&amp;i32) -&gt; bool,
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>The lifetime flows from input through closure logic to output. Generic function type parameter <code>F</code> represents the closure, and closure borrows match the input lifetime. Mental shortcut: "Closure borrows, doesn't own" → input lifetime flows through. Used when applying user-provided logic to borrowed data.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Pattern 8 Iterator Patterns</h2>
<p>What is the correct signature for a function returning an iterator over borrowed data, and why is the <code>+ 'a</code> bound necessary?</p>
<pre><code class="language-rust">fn get_words&lt;'a&gt;(text: &amp;'a str) -&gt; impl Iterator&lt;Item = &amp;'a str&gt; + 'a {
    text.split_whitespace()
}
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Return type is <code>impl Iterator&lt;Item = &amp;'a T&gt; + 'a</code>. The <code>+ 'a</code> bound means the iterator itself can't outlive the data it borrows from. Items yielded have lifetime tied to input. Without the <code>+ 'a</code>, the iterator type could theoretically live longer than the borrowed data. Mental shortcut: "Iterator yields borrowed slices" → lifetime propagates.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Pattern 9 Multiple Return References</h2>
<p>When returning multiple references (tuple or struct), what lifetime pattern is typically used?</p>
<pre><code class="language-rust">fn split_first&lt;'a&gt;(data: &amp;'a [i32]) -&gt; Option&lt;(&amp;'a i32, &amp;'a [i32])&gt; {
    data.split_first()
}
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>All returned references typically share the same lifetime from the same source. Used for splitting, partitioning, or decomposing borrowed data. Mental shortcut: "All pieces from same whole" → same lifetime for all. When returning references together, they need to share a lifetime so the caller knows how long the entire return value is valid.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Pattern 10 Lifetime Bounds in Generics</h2>
<p>When and why do you need the lifetime bound <code>T: 'a</code> in generic functions?</p>
<pre><code class="language-rust">fn store_reference&lt;'a, T&gt;(container: &amp;'a mut Container&lt;T&gt;, item: &amp;'a T)
where
    T: 'a,  // T must live at least as long as 'a
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Use <code>T: 'a</code> when a generic type <code>T</code> might contain references that need to live at least as long as <code>'a</code>. This ensures any references inside <code>T</code> remain valid for the duration of <code>'a</code>. Common with trait objects and generic containers. Mental shortcut: "Generic might have references inside" → add lifetime bound.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Builder Pattern Fluent API</h2>
<p>How does the lifetime work in builder/fluent API patterns where methods return <code>&amp;mut self</code>?</p>
<pre><code class="language-rust">impl&lt;'a&gt; Config&lt;'a&gt; {
    fn set(&amp;mut self, key: String, value: String) -&gt; &amp;mut Self {
        self.settings.insert(key, value);
        self
    }
}
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Methods return <code>&amp;mut Self</code> to enable method chaining. The lifetime of the returned mutable reference is tied to the original borrow of <code>self</code>. This allows fluent method chains like <code>config.set(k1, v1).set(k2, v2)</code>. The borrow is held through the entire chain and released at the end.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>String Processing Pattern</h2>
<p>What lifetime pattern is used when extracting a substring from borrowed text?</p>
<pre><code class="language-rust">fn get_line&lt;'a&gt;(text: &amp;'a str, line_num: usize) -&gt; Option&lt;&amp;'a str&gt; {
    text.lines().nth(line_num)
}
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>This uses Pattern 1 (Input-Output Flow, Single Source). The output substring is a slice of the input text, so it has the same lifetime <code>'a</code> as the input. The line number is a value type (usize), not a reference, so it doesn't affect lifetimes.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Parser State Machine Pattern</h2>
<p>What lifetime pattern do parser/lexer types typically use when maintaining position in borrowed input?</p>
<pre><code class="language-rust">struct Lexer&lt;'a&gt; {
    input: &amp;'a str,
    position: usize,
}
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Parsers store a reference to input data with lifetime <code>'a</code> along with position/state. Methods can return slices of the input with lifetime <code>'a</code>. This is Pattern 6 (Struct Methods with Lifetime Parameters). The struct "owns" the lifetime, and methods inherit it for returning references to portions of the input.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Gotcha Over-Constraining Multiple Sources</h2>
<p>What's the problem with this signature, and how would you fix it?</p>
<pre><code class="language-rust">fn find_or_default&lt;'a&gt;(
    data: &amp;'a [i32],
    target: i32,
    default: &amp;'a i32
) -&gt; &amp;'a i32
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Too restrictive—it forces <code>default</code> to have the same lifetime as <code>data</code> and the return value, even though the return never uses <code>default</code> when a match is found. Fix by using independent lifetimes:</p>
<pre><code class="language-rust">fn find_or_default&lt;'a, 'b&gt;(
    data: &amp;'a [i32],
    target: i32,
    default: &amp;'b i32
) -&gt; &amp;'a i32
</code></pre>
<p>This allows <code>default</code> to have a different (shorter) lifetime.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Gotcha Methods Cannot Return References to Locals</h2>
<p>Why won't this method compile, and what are the two ways to fix it?</p>
<pre><code class="language-rust">impl Container {
    fn get_uppercase(&amp;self) -&gt; &amp;str {
        let upper = self.data.to_uppercase();
        &amp;upper  // upper dropped here!
    }
}
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p><code>upper</code> is a local variable that gets dropped at the end of the method, so you can't return a reference to it. Two fixes: (1) Return owned data: <code>fn get_uppercase(&amp;self) -&gt; String { self.data.to_uppercase() }</code>, or (2) Return reference to existing data in self: <code>fn get_data(&amp;self) -&gt; &amp;str { &amp;self.data }</code>. Methods can only return references to data that outlives the method call.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Gotcha Missing Iterator Lifetime Bound</h2>
<p>What's missing from this signature, and why is it needed?</p>
<pre><code class="language-rust">fn get_words&lt;'a&gt;(text: &amp;'a str) -&gt; impl Iterator&lt;Item = &amp;'a str&gt; {
    text.split_whitespace()
}
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Missing the <code>+ 'a</code> bound on the return type. Should be:</p>
<pre><code class="language-rust">impl Iterator&lt;Item = &amp;'a str&gt; + 'a
</code></pre>
<p>The <code>+ 'a</code> ensures the iterator type itself doesn't outlive the borrowed data. Without it, the iterator could theoretically live longer than the data it borrows from, which would be unsafe.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Gotcha Multiple Returns Different Sources</h2>
<p>Why might returning references with different lifetimes in a tuple be problematic?</p>
<pre><code class="language-rust">fn problematic&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; (&amp;'a str, &amp;'b str) {
    (x, y)
}
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>While this compiles, it can be difficult for callers to work with because the two elements of the tuple have different lifetimes. Often it's better to require both to have the same lifetime:</p>
<pre><code class="language-rust">fn fixed&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; (&amp;'a str, &amp;'a str)
</code></pre>
<p>This makes it clear to the caller how long the entire return value is valid—as long as both inputs are valid.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Pattern Decision Tree Question 1</h2>
<p>Using the pattern decision tree, what pattern applies to a function that takes two references and returns a bool?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Pattern 5 (No Output References). Since the function doesn't return a reference, the input lifetimes are independent and usually don't need to be related. Example: <code>fn compare&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; bool</code>. In practice, these lifetimes are often elided.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Pattern Decision Tree Question 2</h2>
<p>Using the pattern decision tree, what pattern applies to a function that takes one slice reference and returns a reference to an element?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Pattern 1 (Input-Output Flow, Single Source). The output reference comes from the one input, so they share the same lifetime. Example: <code>fn first&lt;'a&gt;(data: &amp;'a [i32]) -&gt; &amp;'a i32</code>. Mental shortcut: "Output points into input" → same lifetime.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Pattern Decision Tree Question 3</h2>
<p>Using the pattern decision tree, what pattern applies to a function that takes two string references and returns one of them based on a condition?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Pattern 2 (Multiple Sources, Same Lifetime). Since the return could be either input, both must have the same lifetime and the return shares that lifetime. Example: <code>fn choose&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str, cond: bool) -&gt; &amp;'a str</code>. This ensures both inputs live long enough for the return value.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Connection to Ownership Principles</h2>
<p>How do lifetime patterns reflect Rust's ownership principles?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Each pattern reflects ownership semantics:
- Patterns 1-2: Borrowing portions of owned data
- Pattern 3: Methods borrowing from <code>self</code> (the owner)
- Pattern 4: Distinguishing between borrowed inputs and side effects
- Pattern 5: Temporary borrows that don't escape the function
Lifetimes ensure borrowed data remains valid, while ownership determines who is responsible for cleanup.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Connection to Standard Library APIs</h2>
<p>Which standard library APIs use which common lifetime patterns?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <ul>
<li>Pattern 1: <code>Vec::first</code>, <code>HashMap::get</code> (return reference from collection)</li>
<li>Pattern 2: <code>cmp::max</code>, <code>slice::iter().max()</code> (return one of multiple inputs)</li>
<li>Pattern 3: All getter methods on structs</li>
<li>Pattern 8: All iterator adaptors (<code>map</code>, <code>filter</code>, etc.)</li>
<li>Pattern 9: <code>str::split_at</code>, <code>slice::split_first</code> (return multiple references)
Understanding patterns helps you read and use these APIs intuitively.</li>
</ul>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Why Learn Explicit Patterns Before Elision</h2>
<p>Why is it important to understand explicit lifetime patterns before learning lifetime elision?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Understanding explicit patterns helps you recognize what the compiler is doing automatically when it elides lifetimes. You can contrast "here's the verbose way" (explicit annotations) vs "here's what the compiler infers" (elision). This makes elision feel like a reward—a shorthand for patterns you already understand—rather than confusing magic. It also helps you debug elision edge cases where you need explicit annotations.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Finding Maximum Pattern</h2>
<p>What lifetime pattern does this collection operation use, and why?</p>
<pre><code class="language-rust">fn find_max&lt;'a&gt;(values: &amp;'a [i32]) -&gt; Option&lt;&amp;'a i32&gt; {
    values.iter().max()
}
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Pattern 1 (Input-Output Flow, Single Source). The maximum value is an element within the slice, so the returned reference has the same lifetime <code>'a</code> as the input slice. The <code>Option</code> accounts for the case of an empty slice. This is the same pattern used for any operation that extracts or filters elements from a collection.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
            </div>
        </div>
        <div class="row">
            <div class="col ms-3">
                <button class="btn btn-dark btn-lg btn-outline-light w-100" type="button" data-bs-target="#carousel"
                    data-bs-slide="prev">
                    <!-- <span class="carousel-control-prev-icon" aria-hidden="true"></span> -->
                    <span class="">Previous</span>
                </button>
            </div>
            <div class="col me-3">
                <button class="btn btn-dark btn-lg btn-outline-light w-100" type="button" data-bs-target="#carousel"
                    data-bs-slide="next">
                    <!-- <span class="carousel-control-next-icon" aria-hidden="true"></span> -->
                    <span class="">Next</span>
                </button>
            </div>
        </div>
    </div>
</div>
<style>
    .flip-card {
        background-color: transparent;
        /* width: 200px; */
        height: 300px;
        /* border: 1px solid #f1f1f1; */
        /* perspective: 1000px; */
        /* Remove this if you don't want the 3D effect */
    }

    /* This container is needed to position the front and back side */
    .flip-card-inner {
        position: relative;
        width: 100%;
        height: 100%;
        /* text-align: center; */
        transition: transform 0.8s;
        transform-style: preserve-3d;
    }

    /* Do an horizontal flip when you move the mouse over the flip box container */
    /* .flip-card:hover .flip-card-inner {
        transform: rotateY(180deg);
    } */

    /* Position the front and back side */
    .flip-card-front,
    .flip-card-back {
        position: absolute;
        width: 100%;
        height: 100%;
        -webkit-backface-visibility: hidden;
        /* Safari */
        backface-visibility: hidden;
    }

    /* Style the front side (fallback if image is missing) */
    /* .flip-card-front {
        background-color: #bbb;
        color: black;
    } */

    /* Style the back side */
    .flip-card-back {
        /* background-color: dodgerblue;
        color: white; */
        transform: rotateY(180deg);
    }

    .vertical-center {
        margin: 0;
        position: absolute;
        top: 50%;
        -ms-transform: translateY(-50%);
        transform: translateY(-50%);
    }

    pre {
        white-space: pre-wrap;
    }

    .card-body {
        overflow: auto;
    }
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script>
    document.querySelector(".carousel-item").classList.add("active")
    const myCarouselElement = document.querySelector('#carousel')
    const carousel = new bootstrap.Carousel(myCarouselElement, {
        touch: true
    });
</script>
<script>
    hljs.highlightAll();

    document.addEventListener('DOMContentLoaded', (event) => {
        const flipCards = document.querySelectorAll('.flip-card');

        flipCards.forEach(flipCard => {
            const flipCardInner = flipCard.querySelector('.flip-card-inner');
            let isFlipped = false;

            flipCard.addEventListener('click', () => {
                if (isFlipped) {
                    flipCardInner.style.transform = 'rotateY(0deg)';
                } else {
                    flipCardInner.style.transform = 'rotateY(180deg)';
                }
                isFlipped = !isFlipped;
            });
        });
    });
</script>

      </div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.min.js"
    integrity="sha384-0pUGZvbkm6XF6gxjEnlmuGrJXVbNuzT9qBBavbLwCsOGabYfZo0T0to5eqruptLy"
    crossorigin="anonymous"></script>
</body>

</html>