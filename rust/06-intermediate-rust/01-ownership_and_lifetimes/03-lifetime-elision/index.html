<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="noindex, nofollow">
  <title>Flashcards - Rust - 06-Intermediate-Rust - 01-Ownership And Lifetimes - 03-Lifetime-Elision</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
</head>

<body class="text-bg-dark">
  <div class="d-flex flex-column min-vh-100 min-vw-100">
    <div class="d-flex flex-grow-1 justify-content-center align-items-center">
      <div class="d-grid gap-2 col-12 mx-auto">
        
<div id="carousel" class="carousel slide">
    <div class="container">
        <div class="row">
            <!-- <div class="carousel-inner" style="width: 70%; margin-left: 15%;"> -->
            <div class="carousel-inner">

                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>What Is Lifetime Elision?</h2>
<p>What is lifetime elision in Rust, and why does it exist?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Lifetime elision is a set of rules the Rust compiler uses to automatically infer lifetime annotations in common patterns, allowing you to omit them from your code. It exists because early Rust required explicit lifetime annotations everywhere, which was verbose and tedious. The Rust team noticed most lifetime annotations followed predictable patterns, so they added elision rules to let the compiler infer them automatically. It's purely syntactic sugar—the compiled code is identical.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Elision Is Not Magic</h2>
<p>What is lifetime elision NOT?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Lifetime elision is NOT:
- Magic: The compiler follows mechanical rules, not AI inference
- Always applicable: Some signatures still need explicit annotations
- A different type of lifetime: Elided lifetimes follow the same rules as explicit ones
- Optional: When elision rules apply, you must omit annotations (or they must match what elision would infer)</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Elision Rule 1 Each Input Gets Own Lifetime</h2>
<p>What is Elision Rule 1, and what does it do?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Rule 1: Each elided lifetime in function parameters gets its own distinct lifetime parameter.</p>
<p>Example:</p>
<pre><code class="language-rust">// What you write
fn foo(x: &amp;i32, y: &amp;i32) -&gt; i32

// What the compiler sees
fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32) -&gt; i32
</code></pre>
<p>This applies to all reference parameters without explicit lifetimes. The rule exists because when a function doesn't return references, input lifetimes don't need to be related.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Elision Rule 2 Single Input to Output</h2>
<p>What is Elision Rule 2, and when does it apply?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Rule 2: If there's exactly one input lifetime parameter (elided or explicit), that lifetime is assigned to all elided output lifetimes.</p>
<p>Example:</p>
<pre><code class="language-rust">// What you write
fn first_word(s: &amp;str) -&gt; &amp;str

// What the compiler sees
fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str
</code></pre>
<p>This applies to functions with exactly one reference input. The rule exists because when there's only one input reference, any returned reference must come from it—the most common pattern.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Elision Rule 3 Method Self to Output</h2>
<p>What is Elision Rule 3, and when does it apply?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Rule 3: If there are multiple input lifetime parameters, but one is <code>&amp;self</code> or <code>&amp;mut self</code>, the lifetime of <code>self</code> is assigned to all elided output lifetimes.</p>
<p>Example:</p>
<pre><code class="language-rust">// What you write
impl MyStruct {
    fn get_data(&amp;self) -&gt; &amp;str { ... }
}

// What the compiler sees
impl MyStruct {
    fn get_data&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a str { ... }
}
</code></pre>
<p>This applies to methods (functions with <code>self</code> parameter). Methods typically return references to data owned by <code>self</code>—the second most common pattern.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>When Elision Fails</h2>
<p>What happens when the three elision rules cannot determine all lifetimes in a signature?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>If after applying all three rules any output lifetime remains unresolved, the compiler requires explicit annotations. Example:</p>
<pre><code class="language-rust">// ❌ Won't compile - ambiguous
fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str

// After Rule 1: separate lifetimes for x and y
// Rules 2 and 3 don't apply (multiple inputs, not a method)
// Output lifetime still unknown → ERROR

// ✅ Explicit annotation required
fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str
</code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Elision Order of Application</h2>
<p>In what order does the compiler apply the three elision rules?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>The compiler applies the rules in order: Rule 1, then Rule 2, then Rule 3. If all lifetimes can be determined after applying these rules, elision succeeds. If any ambiguity remains, you must write explicit annotations. The rules are mechanical and deterministic—there's no guessing or AI involved.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Pattern Single Input Single Output</h2>
<p>Which elision rule applies to this pattern, and why does it work?</p>
<pre><code class="language-rust">fn first_word(s: &amp;str) -&gt; &amp;str {
    s.split_whitespace().next().unwrap_or(&quot;&quot;)
}
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Rule 2 applies. There's exactly one input reference (<code>s</code>), so that lifetime is assigned to the output. The expanded version is:</p>
<pre><code class="language-rust">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str
</code></pre>
<p>This works because with only one input reference, any returned reference must come from it.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Pattern Multiple Inputs No Output</h2>
<p>Which elision rule applies when a function has multiple reference inputs but doesn't return references?</p>
<pre><code class="language-rust">fn compare(x: &amp;str, y: &amp;str) -&gt; bool {
    x.len() &gt; y.len()
}
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Rule 1 applies (each input gets its own lifetime), but since there are no output references, lifetime relationships don't matter. Expanded:</p>
<pre><code class="language-rust">fn compare&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; bool
</code></pre>
<p>This works because without output references, the input lifetimes don't need to be related.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Pattern Method Returning Reference to Self</h2>
<p>Which elision rule applies to methods that return references?</p>
<pre><code class="language-rust">impl Container {
    fn get_data(&amp;self) -&gt; &amp;str {
        &amp;self.data
    }
}
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Rule 3 applies. With multiple inputs (including <code>&amp;self</code>), the lifetime of <code>self</code> is assigned to output lifetimes. Expanded:</p>
<pre><code class="language-rust">impl Container {
    fn get_data&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a str {
        &amp;self.data
    }
}
</code></pre>
<p>This works because methods returning references almost always return data from <code>self</code>.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Pattern Method with Additional Parameters</h2>
<p>Does Rule 3 still apply when a method has additional reference parameters beyond <code>&amp;self</code>?</p>
<pre><code class="language-rust">impl Parser {
    fn parse_with_default(&amp;self, default: &amp;str) -&gt; &amp;str {
        self.current_token()
    }
}
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Yes, Rule 3 applies even with multiple inputs. It prioritizes <code>self</code>'s lifetime for outputs. Expanded:</p>
<pre><code class="language-rust">impl Parser {
    fn parse_with_default&lt;'a, 'b&gt;(&amp;'a self, default: &amp;'b str) -&gt; &amp;'a str
</code></pre>
<p>The returned reference is tied to <code>self</code>'s lifetime, not <code>default</code>'s lifetime.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Gotcha Multiple Inputs Reference Output</h2>
<p>Why doesn't elision work for this function, and what's needed?</p>
<pre><code class="language-rust">fn choose(x: &amp;str, y: &amp;str, condition: bool) -&gt; &amp;str {
    if condition { x } else { y }
}
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>After Rule 1, inputs have separate lifetimes <code>'a</code> and <code>'b</code>. Rules 2 and 3 don't apply (multiple inputs, not a method). The compiler can't determine which input's lifetime the output should have. Fix with explicit annotations:</p>
<pre><code class="language-rust">fn choose&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str, condition: bool) -&gt; &amp;'a str
</code></pre>
<p>This explicitly states the output could come from either input.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Gotcha Mixing Elided and Explicit</h2>
<p>What's the problem with mixing elided and explicit lifetimes in a signature?</p>
<pre><code class="language-rust">fn example&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Mixing elision and explicit lifetimes in a signature is confusing and often indicates a design issue. Be consistent—either use elision throughout or use explicit lifetimes throughout. This signature should be either:</p>
<pre><code class="language-rust">// All explicit
fn example&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;'a str
// Or let both elide if possible
</code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Gotcha Method Returning Non-Self Reference</h2>
<p>Why might elision not work correctly for this method, and what's the fix?</p>
<pre><code class="language-rust">impl&lt;'a&gt; Processor&lt;'a&gt; {
    fn process(&amp;self, input: &amp;str) -&gt; &amp;str {
        // Process and return part of input, not self
    }
}
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Rule 3 assumes methods return references from <code>self</code>, assigning <code>self</code>'s lifetime to the output. When the method actually returns from <code>input</code>, you need explicit annotations:</p>
<pre><code class="language-rust">impl&lt;'a&gt; Processor&lt;'a&gt; {
    fn process&lt;'b&gt;(&amp;self, input: &amp;'b str) -&gt; &amp;'b str {
        // Return explicitly tied to input, not self
    }
}
</code></pre>
<p>This clarifies the output comes from <code>input</code>, not <code>self</code>.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Gotcha Iterator Return Types</h2>
<p>What's missing from this iterator function signature, and why is it required?</p>
<pre><code class="language-rust">fn get_words(text: &amp;str) -&gt; impl Iterator&lt;Item = &amp;str&gt; {
    text.split_whitespace()
}
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Missing the lifetime bound <code>+ 'a</code>. The correct signature is:</p>
<pre><code class="language-rust">fn get_words&lt;'a&gt;(text: &amp;'a str) -&gt; impl Iterator&lt;Item = &amp;'a str&gt; + 'a {
    text.split_whitespace()
}
</code></pre>
<p>The <code>+ 'a</code> bound can't be elided—it must be explicit to ensure the iterator type itself doesn't outlive the borrowed data it yields from.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Static Lifetimes and Elision</h2>
<p>Can <code>'static</code> lifetimes be elided?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>No, <code>'static</code> is special and must be written explicitly when part of a return type:</p>
<pre><code class="language-rust">fn get_constant() -&gt; &amp;'static str {
    &quot;hello, world&quot;
}
</code></pre>
<p>However, string/byte literals and constants have implicit <code>'static</code> lifetimes:</p>
<pre><code class="language-rust">const GREETING: &amp;str = &quot;hello&quot;;  // Implicit 'static
</code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Elision Decision Tree Step 1</h2>
<p>In the elision decision tree, what's the first question to ask about a function signature?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>"Does the function signature have reference inputs?" If NO, no lifetimes are needed. If YES, proceed to check if it returns references. This is the foundation of the decision tree because lifetimes only matter when references are involved.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Elision Decision Tree Step 2</h2>
<p>After confirming a function has reference inputs, what's the next question in the elision decision tree?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>"Does it return references?" If NO, Rule 1 applies (separate lifetimes for inputs), and you're done—lifetime relationships don't matter. If YES, you need to determine how many reference inputs there are and whether it's a method to see if Rules 2 or 3 apply.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Connection to Lifetime Patterns</h2>
<p>Which common lifetime patterns do the elision rules automatically implement?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <ul>
<li>Rule 2 implements Pattern 1 (single input → output)</li>
<li>Rule 3 implements Pattern 3 (method returning from self)</li>
<li>Rules don't matter for Pattern 5 (no output references)</li>
</ul>
<p>Patterns that need explicit annotations: Pattern 2 (multiple sources, same lifetime) and Pattern 4 (multiple independent lifetimes) where relationships are non-obvious.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Elision and API Design</h2>
<p>How does understanding elision influence good API design in Rust?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Good API design often aligns with elision rules because functions that follow elision patterns are easier to use and understand. For example:</p>
<pre><code class="language-rust">// Good: Follows elision naturally
impl Config {
    fn get_value(&amp;self, key: &amp;str) -&gt; Option&lt;&amp;str&gt;
}

// Less ergonomic: Requires explicit lifetimes
fn merge&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str
</code></pre>
<p>When possible, design APIs so their most common usage patterns work with elision.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Elision and Code Readability</h2>
<p>How does lifetime elision affect code readability?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Elision reduces noise in common cases, making code clearer:</p>
<pre><code class="language-rust">// With elision - clearer intent
fn process_data(input: &amp;[u8]) -&gt; &amp;[u8]

// Without elision - harder to read
fn process_data&lt;'a&gt;(input: &amp;'a [u8]) -&gt; &amp;'a [u8]
</code></pre>
<p>However, explicit annotations clarify complex relationships when elision doesn't apply. The key is using each appropriately.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Interpreting Elision Compiler Errors</h2>
<p>What does this compiler error mean in terms of elision rules?</p>
<pre><code>error: missing lifetime specifier
fn example(x: &amp;str, y: &amp;str) -&gt; &amp;str
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>This error means: "I applied Rule 1 (gave each input separate lifetimes), but can't determine the output lifetime because Rules 2 and 3 don't apply." Rule 2 doesn't apply (multiple inputs), and Rule 3 doesn't apply (not a method). You need to explicitly specify which input(s) the output lifetime relates to.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Why Learn Explicit Before Elision</h2>
<p>Why is it important to learn explicit lifetimes before learning elision?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Learning explicit lifetimes first prevents elision from seeming like "magic" and helps you:
1. Understand what the compiler is doing automatically
2. Debug edge cases where elision doesn't apply
3. Read old Rust code with verbose annotations
4. Recognize when explicit annotations are needed
5. Make the learning progression: explicit → elision → recognize when to use each</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Debugging Missing Lifetime Specifier</h2>
<p>What steps should you take when you get a "missing lifetime specifier" error?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <ol>
<li>Count reference inputs in the function</li>
<li>Check if there's output with references</li>
<li>Apply elision rules mentally:</li>
<li>One input? Rule 2 should work</li>
<li>Multiple inputs with &amp;self? Rule 3 should work</li>
<li>Multiple inputs without &amp;self? Need explicit annotations</li>
<li>If ambiguity remains, add explicit annotations showing which input(s) the output relates to</li>
</ol>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Elision with Struct Lifetime Parameters</h2>
<p>How does elision work with methods on structs that have lifetime parameters?</p>
<pre><code class="language-rust">struct Container&lt;'a&gt; {
    data: &amp;'a str,
}

impl&lt;'a&gt; Container&lt;'a&gt; {
    fn get_data(&amp;self) -&gt; &amp;str {
        self.data
    }
}
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Rule 3 applies. The returned <code>&amp;str</code> is elided to <code>&amp;'a str</code> because <code>self</code>'s lifetime is <code>'a</code>. The explicit version is:</p>
<pre><code class="language-rust">fn get_data(&amp;self) -&gt; &amp;'a str
</code></pre>
<p>The method inherits the struct's lifetime parameter for its return type, allowing clean elision in the signature.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
            </div>
        </div>
        <div class="row">
            <div class="col ms-3">
                <button class="btn btn-dark btn-lg btn-outline-light w-100" type="button" data-bs-target="#carousel"
                    data-bs-slide="prev">
                    <!-- <span class="carousel-control-prev-icon" aria-hidden="true"></span> -->
                    <span class="">Previous</span>
                </button>
            </div>
            <div class="col me-3">
                <button class="btn btn-dark btn-lg btn-outline-light w-100" type="button" data-bs-target="#carousel"
                    data-bs-slide="next">
                    <!-- <span class="carousel-control-next-icon" aria-hidden="true"></span> -->
                    <span class="">Next</span>
                </button>
            </div>
        </div>
    </div>
</div>
<style>
    .flip-card {
        background-color: transparent;
        /* width: 200px; */
        height: 300px;
        /* border: 1px solid #f1f1f1; */
        /* perspective: 1000px; */
        /* Remove this if you don't want the 3D effect */
    }

    /* This container is needed to position the front and back side */
    .flip-card-inner {
        position: relative;
        width: 100%;
        height: 100%;
        /* text-align: center; */
        transition: transform 0.8s;
        transform-style: preserve-3d;
    }

    /* Do an horizontal flip when you move the mouse over the flip box container */
    /* .flip-card:hover .flip-card-inner {
        transform: rotateY(180deg);
    } */

    /* Position the front and back side */
    .flip-card-front,
    .flip-card-back {
        position: absolute;
        width: 100%;
        height: 100%;
        -webkit-backface-visibility: hidden;
        /* Safari */
        backface-visibility: hidden;
    }

    /* Style the front side (fallback if image is missing) */
    /* .flip-card-front {
        background-color: #bbb;
        color: black;
    } */

    /* Style the back side */
    .flip-card-back {
        /* background-color: dodgerblue;
        color: white; */
        transform: rotateY(180deg);
    }

    .vertical-center {
        margin: 0;
        position: absolute;
        top: 50%;
        -ms-transform: translateY(-50%);
        transform: translateY(-50%);
    }

    pre {
        white-space: pre-wrap;
    }

    .card-body {
        overflow: auto;
    }
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script>
    document.querySelector(".carousel-item").classList.add("active")
    const myCarouselElement = document.querySelector('#carousel')
    const carousel = new bootstrap.Carousel(myCarouselElement, {
        touch: true
    });
</script>
<script>
    hljs.highlightAll();

    document.addEventListener('DOMContentLoaded', (event) => {
        const flipCards = document.querySelectorAll('.flip-card');

        flipCards.forEach(flipCard => {
            const flipCardInner = flipCard.querySelector('.flip-card-inner');
            let isFlipped = false;

            flipCard.addEventListener('click', () => {
                if (isFlipped) {
                    flipCardInner.style.transform = 'rotateY(0deg)';
                } else {
                    flipCardInner.style.transform = 'rotateY(180deg)';
                }
                isFlipped = !isFlipped;
            });
        });
    });
</script>

      </div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.min.js"
    integrity="sha384-0pUGZvbkm6XF6gxjEnlmuGrJXVbNuzT9qBBavbLwCsOGabYfZo0T0to5eqruptLy"
    crossorigin="anonymous"></script>
</body>

</html>