<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="noindex, nofollow">
  <title>Flashcards - Rust - 06-Intermediate-Rust - 01-Ownership And Lifetimes - 01-Lifetime-Annotations</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
</head>

<body class="text-bg-dark">
  <div class="d-flex flex-column min-vh-100 min-vw-100">
    <div class="d-flex flex-grow-1 justify-content-center align-items-center">
      <div class="d-grid gap-2 col-12 mx-auto">
        
<div id="carousel" class="carousel slide">
    <div class="container">
        <div class="row">
            <!-- <div class="carousel-inner" style="width: 70%; margin-left: 15%;"> -->
            <div class="carousel-inner">

                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>What Are Lifetimes in Rust?</h2>
<p>What are lifetime annotations in Rust, and what problem do they solve?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Lifetime annotations are labels that describe the scope during which a reference remains valid. They solve the problem of tracking how long referenced data is valid so the borrow checker can prevent dangling references. Lifetimes don't change how long data lives—they describe relationships between the lifetimes of different references to verify safety at compile time.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Lifetime Syntax Basics</h2>
<p>What is the syntax for declaring and using a lifetime parameter in a function signature?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Lifetimes are declared with angle brackets after the function name and used with the <code>&amp;</code> reference operator:</p>
<pre><code class="language-rust">fn function_name&lt;'a&gt;(param: &amp;'a Type) -&gt; &amp;'a Type
</code></pre>
<p>The <code>&lt;'a&gt;</code> declares a generic lifetime parameter (like <code>&lt;T&gt;</code> for types), and <code>&amp;'a Type</code> indicates a reference with lifetime <code>'a</code>. The lifetime name must be declared before it can be used.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Lifetime Annotation Pronunciation</h2>
<p>How do you pronounce <code>'a</code> in Rust lifetime annotations?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p><code>'a</code> is pronounced "tick-a" or "lifetime-a". The single quote followed by a letter is the standard syntax for lifetime parameters.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Longest Function Signature Meaning</h2>
<p>What does this function signature tell you about lifetime relationships?</p>
<pre><code class="language-rust">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>This signature means:
- There exists some lifetime <code>'a</code>
- Both <code>x</code> and <code>y</code> must be valid for at least <code>'a</code>
- The returned reference will be valid for <code>'a</code>
- Therefore, the return value is valid as long as BOTH inputs are valid (the shorter of the two lifetimes determines <code>'a</code>)</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Multiple Independent Lifetimes</h2>
<p>When and why would you use multiple lifetime parameters like <code>'a</code> and <code>'b</code> in a function signature?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>You use multiple lifetime parameters when the return lifetime depends on only one input, or when inputs have independent validity requirements. Example:</p>
<pre><code class="language-rust">fn first_word&lt;'a, 'b&gt;(x: &amp;'a str, _y: &amp;'b str) -&gt; &amp;'a str
</code></pre>
<p>This tells the caller that the return lifetime matches only <code>x</code>, not <code>y</code>. This is less restrictive than requiring both parameters to have the same lifetime.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Compile-Time vs Runtime Cost</h2>
<p>Do lifetime annotations have any runtime cost or performance impact?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>No. Lifetimes are entirely a compile-time concept with zero runtime cost. They exist only for borrow checker verification during compilation and are erased before the program runs. This is part of Rust's zero-cost abstractions philosophy.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Lifetimes Are Descriptive Not Prescriptive</h2>
<p>Do lifetime annotations change how long data actually lives?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>No. Lifetimes are descriptive, not prescriptive. They describe existing relationships between references but don't change how long data lives. Data lifetime is determined by scope and ownership—lifetime annotations just help the compiler verify that references remain valid.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Returning References to Local Variables</h2>
<p>Why does this code fail to compile, and what's the solution?</p>
<pre><code class="language-rust">fn dangle&lt;'a&gt;() -&gt; &amp;'a String {
    let s = String::from(&quot;hello&quot;);
    &amp;s
}
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>This fails because <code>s</code> is owned locally and dropped at the end of the function, creating a dangling reference. Lifetime annotations can't make data live longer than its scope. The solution is to return owned data instead:</p>
<pre><code class="language-rust">fn no_dangle() -&gt; String {
    String::from(&quot;hello&quot;)  // Ownership transferred
}
</code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Over-Constraining with Same Lifetime</h2>
<p>What's wrong with using the same lifetime for all parameters when not necessary?</p>
<pre><code class="language-rust">fn process&lt;'a&gt;(input: &amp;'a str, buffer: &amp;'a mut String) -&gt; &amp;'a str {
    buffer.push_str(input);
    input
}
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>This is too restrictive because it forces <code>buffer</code> to live as long as the return value, even though the return is only tied to <code>input</code>. Use independent lifetimes when parameters aren't related:</p>
<pre><code class="language-rust">fn process&lt;'a, 'b&gt;(input: &amp;'a str, buffer: &amp;'b mut String) -&gt; &amp;'a str {
    buffer.push_str(input);
    input
}
</code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Lifetime Parameter Names Are Arbitrary</h2>
<p>Do lifetime parameter names like <code>'a</code> and <code>'b</code> have special meaning in Rust?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>No, lifetime names are arbitrary labels with no inherent meaning. <code>'a</code>, <code>'b</code>, <code>'x</code>, <code>'y</code> are all equivalent—just like generic type parameter names. By convention, Rust code uses <code>'a</code>, <code>'b</code>, <code>'c</code> in sequence, but any valid identifier works. The relationships defined in the signature are what matter, not the names.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Lifetimes as Generic Parameters</h2>
<p>How are lifetime parameters similar to generic type parameters?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Lifetimes are generic parameters, just like types. They're declared similarly and can be combined:</p>
<pre><code class="language-rust">fn example&lt;'a, T&gt;(x: &amp;'a T) -&gt; &amp;'a T { x }
//         ^^  ^   lifetime  type
</code></pre>
<p>Both are compile-time abstractions that the compiler monomorphizes. You can have lifetime bounds just like trait bounds.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>The Static Lifetime</h2>
<p>What does the <code>'static</code> lifetime mean, and when is it used?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p><code>'static</code> is a special lifetime meaning "lives for the entire program duration". It's used for:
- String literals: <code>let s: &amp;'static str = "hello";</code> (stored in program binary)
- Static constants: <code>const MAX: i32 = 100;</code>
- Global variables</p>
<p>It's NOT the same as owned data—<code>String::from("hello")</code> is owned but not <code>'static</code>.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Lifetime Subtyping Relationship</h2>
<p>What does the lifetime bound <code>'b: 'a</code> mean?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p><code>'b: 'a</code> means "<code>'b</code> outlives <code>'a</code>" or "<code>'b</code> lives at least as long as <code>'a</code>". This is a lifetime bound that establishes a hierarchy. If <code>'a</code> ⊇ <code>'b</code> in scope terms, then <code>'b</code> is a subset of <code>'a</code>, so <code>'b: 'a</code> in bound syntax. Rust can often infer these relationships automatically.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Pattern All Parameters Share Lifetime</h2>
<p>When should you use the same lifetime <code>'a</code> for all parameters and the return value?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Use the same lifetime when the return value could come from any of the inputs, so all must live long enough. Example:</p>
<pre><code class="language-rust">fn pick_one&lt;'a&gt;(x: &amp;'a i32, y: &amp;'a i32, condition: bool) -&gt; &amp;'a i32 {
    if condition { x } else { y }
}
</code></pre>
<p>This ensures both inputs remain valid for as long as the output is used.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Pattern Return Tied to One Input</h2>
<p>When should you use different lifetimes for different parameters?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Use different lifetimes when the return clearly comes from one specific input:</p>
<pre><code class="language-rust">fn get_first&lt;'a&gt;(values: &amp;'a [i32], _default: &amp;i32) -&gt; &amp;'a i32 {
    &amp;values[0]
}
</code></pre>
<p>Here the return is tied only to <code>values</code>, not <code>_default</code>, so <code>_default</code> can have an independent (potentially shorter) lifetime.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Pattern No References Returned</h2>
<p>Do you need to relate lifetimes when a function doesn't return any references?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Usually no. When no references are returned, input lifetimes are often independent:</p>
<pre><code class="language-rust">fn compare&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; bool {
    x.len() &gt; y.len()
}
</code></pre>
<p>The function only uses the inputs temporarily, so their lifetimes don't need to be related. (In practice, lifetime elision often makes these annotations unnecessary.)</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Lifetime Constraint Flow Example</h2>
<p>Why doesn't this compile?</p>
<pre><code class="language-rust">let string1 = String::from(&quot;long&quot;);
let result;
{
    let string2 = String::from(&quot;short&quot;);
    result = longest(string1.as_str(), string2.as_str());
}
println!(&quot;{}&quot;, result);
</code></pre>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>The borrow checker reasons: <code>result</code> needs lifetime <code>'a</code>, which must be valid for both <code>string1</code> AND <code>string2</code>. But <code>string2</code> dies at the closing brace, ending <code>'a</code>, while <code>result</code> is used after that point. Solution: keep <code>string2</code> alive until after the <code>println!</code>.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Reading Lifetime Error Messages</h2>
<p>What steps should you take when encountering a lifetime mismatch error?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <ol>
<li>Find what lifetimes are involved in the error</li>
<li>Identify which parameter's lifetime doesn't match expectations</li>
<li>Ask: "Which input does the output actually come from?"</li>
<li>Apply the right pattern:</li>
<li>Return from multiple inputs → same lifetime</li>
<li>Return from one input → tie to that lifetime only</li>
<li>Return is independent (e.g., string literal) → use <code>'static</code></li>
</ol>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Borrowing Rules vs Lifetime Issues</h2>
<p>How do you distinguish between a borrowing rule violation and a lifetime issue?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Borrowing rules are about simultaneous access (can't have <code>&amp;mut</code> and <code>&amp;</code> at once, or two <code>&amp;mut</code>). Lifetime issues are about validity duration (references outliving data). Example of borrowing issue (not lifetime):</p>
<pre><code class="language-rust">fn bad(v: &amp;mut Vec&lt;i32&gt;) -&gt; (&amp;mut i32, &amp;mut i32) {
    (&amp;mut v[0], &amp;mut v[1])  // Can't have two &amp;mut to same Vec!
}
</code></pre>
<p>This fails borrowing rules regardless of lifetimes.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Lifetime Connection to Ownership</h2>
<p>How do lifetimes relate to Rust's ownership system?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Ownership determines who is responsible for cleanup, while lifetimes determine how long borrowed data remains valid. Lifetimes enforce that references never outlive what they point to—this is the bridge between ownership (who owns it) and borrowing (who can use it temporarily). Together they ensure memory safety without garbage collection.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Lifetime Bounds in Generic Functions</h2>
<p>Why might you need a lifetime bound like <code>T: 'a</code> in a generic function?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>You need <code>T: 'a</code> when a generic type <code>T</code> might contain references that need to live at least as long as <code>'a</code>:</p>
<pre><code class="language-rust">fn print_ref&lt;'a, T&gt;(x: &amp;'a T)
where
    T: Display + 'a  // T must live at least as long as 'a
{
    println!(&quot;{}&quot;, x);
}
</code></pre>
<p>This ensures any references inside <code>T</code> remain valid for the duration of <code>'a</code>.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>When to Split Lifetimes</h2>
<p>What's the guideline for deciding whether to use one lifetime or multiple lifetimes in a function signature?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Start with one lifetime for all references, then split only when needed. Split when:
- Return is tied to only one input (not all)
- Inputs have genuinely independent validity requirements
- Using one lifetime creates unnecessarily strict constraints</p>
<p>The single-lifetime approach is simpler and often sufficient.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Lifetime Annotations Quick Pattern Reference</h2>
<p>What does each of these signature patterns express?
1. <code>fn f&lt;'a&gt;(x: &amp;'a T) -&gt; &amp;'a T</code>
2. <code>fn f&lt;'a, 'b&gt;(x: &amp;'a T, y: &amp;'b U) -&gt; &amp;'a T</code>
3. <code>fn f&lt;'a&gt;(x: &amp;'a T)</code>
4. <code>where 'b: 'a</code></p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <ol>
<li>Single lifetime: output lifetime tied to input</li>
<li>Multiple lifetimes: output tied to one input only (x)</li>
<li>No output reference: input used temporarily (often elided)</li>
<li>Lifetime bound: <code>'b</code> outlives <code>'a</code> (lives at least as long)</li>
</ol>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Why Compiler Needs Lifetime Annotations</h2>
<p>Why can't the Rust compiler always figure out lifetimes automatically without annotations?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>When a function returns a reference, the compiler needs to know which input(s) it comes from to verify the reference remains valid. With multiple reference inputs, there's ambiguity—the compiler can't determine if the output relates to the first input, second input, or both. Lifetime annotations resolve this ambiguity by explicitly specifying the relationship. (Note: in many simple cases, "lifetime elision" rules DO allow the compiler to infer lifetimes automatically.)</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
            </div>
        </div>
        <div class="row">
            <div class="col ms-3">
                <button class="btn btn-dark btn-lg btn-outline-light w-100" type="button" data-bs-target="#carousel"
                    data-bs-slide="prev">
                    <!-- <span class="carousel-control-prev-icon" aria-hidden="true"></span> -->
                    <span class="">Previous</span>
                </button>
            </div>
            <div class="col me-3">
                <button class="btn btn-dark btn-lg btn-outline-light w-100" type="button" data-bs-target="#carousel"
                    data-bs-slide="next">
                    <!-- <span class="carousel-control-next-icon" aria-hidden="true"></span> -->
                    <span class="">Next</span>
                </button>
            </div>
        </div>
    </div>
</div>
<style>
    .flip-card {
        background-color: transparent;
        /* width: 200px; */
        height: 300px;
        /* border: 1px solid #f1f1f1; */
        /* perspective: 1000px; */
        /* Remove this if you don't want the 3D effect */
    }

    /* This container is needed to position the front and back side */
    .flip-card-inner {
        position: relative;
        width: 100%;
        height: 100%;
        /* text-align: center; */
        transition: transform 0.8s;
        transform-style: preserve-3d;
    }

    /* Do an horizontal flip when you move the mouse over the flip box container */
    /* .flip-card:hover .flip-card-inner {
        transform: rotateY(180deg);
    } */

    /* Position the front and back side */
    .flip-card-front,
    .flip-card-back {
        position: absolute;
        width: 100%;
        height: 100%;
        -webkit-backface-visibility: hidden;
        /* Safari */
        backface-visibility: hidden;
    }

    /* Style the front side (fallback if image is missing) */
    /* .flip-card-front {
        background-color: #bbb;
        color: black;
    } */

    /* Style the back side */
    .flip-card-back {
        /* background-color: dodgerblue;
        color: white; */
        transform: rotateY(180deg);
    }

    .vertical-center {
        margin: 0;
        position: absolute;
        top: 50%;
        -ms-transform: translateY(-50%);
        transform: translateY(-50%);
    }

    pre {
        white-space: pre-wrap;
    }

    .card-body {
        overflow: auto;
    }
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script>
    document.querySelector(".carousel-item").classList.add("active")
    const myCarouselElement = document.querySelector('#carousel')
    const carousel = new bootstrap.Carousel(myCarouselElement, {
        touch: true
    });
</script>
<script>
    hljs.highlightAll();

    document.addEventListener('DOMContentLoaded', (event) => {
        const flipCards = document.querySelectorAll('.flip-card');

        flipCards.forEach(flipCard => {
            const flipCardInner = flipCard.querySelector('.flip-card-inner');
            let isFlipped = false;

            flipCard.addEventListener('click', () => {
                if (isFlipped) {
                    flipCardInner.style.transform = 'rotateY(0deg)';
                } else {
                    flipCardInner.style.transform = 'rotateY(180deg)';
                }
                isFlipped = !isFlipped;
            });
        });
    });
</script>

      </div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.min.js"
    integrity="sha384-0pUGZvbkm6XF6gxjEnlmuGrJXVbNuzT9qBBavbLwCsOGabYfZo0T0to5eqruptLy"
    crossorigin="anonymous"></script>
</body>

</html>