<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="noindex, nofollow">
  <title>Flashcards - Rust - 06-Intermediate-Rust - 03-Iterators-And-Closures - 04-Iterator-Consumers</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
</head>

<body class="text-bg-dark">
  <div class="d-flex flex-column min-vh-100 min-vw-100">
    <div class="d-flex flex-grow-1 justify-content-center align-items-center">
      <div class="d-grid gap-2 col-12 mx-auto">
        
<div id="carousel" class="carousel slide">
    <div class="container">
        <div class="row">
            <!-- <div class="carousel-inner" style="width: 70%; margin-left: 15%;"> -->
            <div class="carousel-inner">

                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Iterator Consumers Definition</h2>
<p>What are iterator consumers? How do they differ from iterator adaptors?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Iterator consumers are terminal operations that consume an iterator and produce a final result, triggering execution of the entire pipeline.</p>
<p><strong>Key differences:</strong></p>
<pre><code class="language-markdown">| Aspect | Adaptors | Consumers |
|--------|----------|-----------|
| Return type | Iterator | Concrete value |
| Execution | Lazy (deferred) | Eager (immediate) |
| Ownership | `self` → Iterator | `self` → Value |
| Chainable | Yes | No (terminal) |
| Examples | map, filter | collect, sum |
</code></pre>
<p><strong>Signatures comparison:</strong></p>
<pre><code class="language-rust">// Adaptor - returns iterator
fn map&lt;F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt;

// Consumer - returns value
fn sum&lt;S&gt;(self) -&gt; S
</code></pre>
<p><strong>Mental model:</strong> If adaptors write a recipe, consumers execute it.</p>
<pre><code class="language-rust">data.iter()
    .filter(predicate)  // Adaptor (lazy)
    .map(transform)     // Adaptor (lazy)
    .collect()          // CONSUMER - triggers execution!
</code></pre>
<p>Consumers are the "execution trigger" - nothing happens until you use one.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Consumer Categories</h2>
<p>What are the six main categories of iterator consumers? Give an example of each.</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Iterator consumers fall into six functional categories:</p>
<p><strong>1. Collection builders</strong> - Materialize into data structures</p>
<pre><code class="language-rust">let vec: Vec&lt;i32&gt; = iter.collect();
let (evens, odds) = iter.partition(|&amp;x| x % 2 == 0);
</code></pre>
<p><strong>2. Reducers</strong> - Aggregate to single value</p>
<pre><code class="language-rust">let sum: i32 = iter.sum();
let stats = iter.fold(initial, |acc, x| update(acc, x));
</code></pre>
<p><strong>3. Searchers</strong> - Find elements or test conditions</p>
<pre><code class="language-rust">let first = iter.find(|x| predicate(x));
let has_any = iter.any(|x| condition(x));
</code></pre>
<p><strong>4. Extractors</strong> - Get specific elements</p>
<pre><code class="language-rust">let third = iter.nth(2);
let max = iter.max();
</code></pre>
<p><strong>5. Counters</strong> - Count elements</p>
<pre><code class="language-rust">let count = iter.count();
</code></pre>
<p><strong>6. Side effect performers</strong> - Execute actions</p>
<pre><code class="language-rust">iter.for_each(|x| println!(&quot;{}&quot;, x));
</code></pre>
<p>Each category serves a different purpose in the final step of processing data.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Collect Universal Builder</h2>
<p>What makes <code>.collect()</code> the "universal builder"? Show three different collection types it can build.</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p><code>.collect()</code> can build any type implementing <code>FromIterator</code>, making it extremely versatile.</p>
<p><strong>Signature:</strong></p>
<pre><code class="language-rust">fn collect&lt;B: FromIterator&lt;Self::Item&gt;&gt;(self) -&gt; B
</code></pre>
<p><strong>Building different collections:</strong></p>
<p><strong>1. Vec:</strong></p>
<pre><code class="language-rust">let vec: Vec&lt;i32&gt; = (1..6).collect();
// [1, 2, 3, 4, 5]
</code></pre>
<p><strong>2. HashSet:</strong></p>
<pre><code class="language-rust">use std::collections::HashSet;
let set: HashSet&lt;i32&gt; = vec![1, 2, 2, 3, 3].into_iter().collect();
// {1, 2, 3} - duplicates removed
</code></pre>
<p><strong>3. HashMap (from pairs):</strong></p>
<pre><code class="language-rust">use std::collections::HashMap;
let map: HashMap&lt;&amp;str, i32&gt; = 
    vec![(&quot;a&quot;, 1), (&quot;b&quot;, 2)].into_iter().collect();
// {&quot;a&quot;: 1, &quot;b&quot;: 2}
</code></pre>
<p><strong>4. String (from chars):</strong></p>
<pre><code class="language-rust">let string: String = vec!['H', 'i'].into_iter().collect();
// &quot;Hi&quot;
</code></pre>
<p><strong>5. Result/Option:</strong></p>
<pre><code class="language-rust">let results: Result&lt;Vec&lt;i32&gt;, _&gt; = 
    strings.iter().map(|s| s.parse()).collect();
// Stops at first error
</code></pre>
<p>The same method builds vastly different types - that's why type annotations are required.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Collect Type Annotations</h2>
<p>Why does <code>.collect()</code> require type annotations? Show all four ways to provide them.</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p><code>.collect()</code> is generic over the output type, so the compiler needs hints about what to build.</p>
<p><strong>Why:</strong> Can produce Vec, HashSet, HashMap, String, Result, Option, etc.</p>
<p><strong>Four ways to provide type:</strong></p>
<p><strong>1. Variable type annotation:</strong></p>
<pre><code class="language-rust">let result: Vec&lt;i32&gt; = iter.collect();
</code></pre>
<p><strong>2. Turbofish syntax:</strong></p>
<pre><code class="language-rust">let result = iter.collect::&lt;Vec&lt;i32&gt;&gt;();
</code></pre>
<p><strong>3. Partial inference (underscore):</strong></p>
<pre><code class="language-rust">let result = iter.collect::&lt;Vec&lt;_&gt;&gt;();
// Compiler infers inner type
</code></pre>
<p><strong>4. Context from usage:</strong></p>
<pre><code class="language-rust">fn process(v: Vec&lt;i32&gt;) { }

process(iter.collect());  // Type inferred from parameter
</code></pre>
<p><strong>Without annotation - error:</strong></p>
<pre><code class="language-rust">let result = iter.collect();  
// ERROR: type annotations needed
</code></pre>
<p><strong>Best practice:</strong> Use variable annotation for clarity at declaration, turbofish when chaining.</p>
<p>The flexibility is a feature - one method for all collection types - but requires explicit type information.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Collect with Result and Option</h2>
<p>How does <code>.collect()</code> behave with iterators of <code>Result</code> or <code>Option</code>? Show both success and failure cases.</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p><code>.collect()</code> has special behavior for Result and Option - it "flips" the container and iterator.</p>
<p><strong>With Result - stops at first error:</strong></p>
<p><strong>Success:</strong></p>
<pre><code class="language-rust">let results: Result&lt;Vec&lt;i32&gt;, _&gt; = 
    vec![&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]
        .iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .collect();
// Ok([1, 2, 3])
</code></pre>
<p><strong>Failure:</strong></p>
<pre><code class="language-rust">let results: Result&lt;Vec&lt;i32&gt;, _&gt; = 
    vec![&quot;1&quot;, &quot;not a number&quot;, &quot;3&quot;]
        .iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .collect();
// Err(ParseIntError) - stops immediately at error
</code></pre>
<p><strong>With Option - None if any is None:</strong></p>
<p><strong>All Some:</strong></p>
<pre><code class="language-rust">let all: Option&lt;Vec&lt;i32&gt;&gt; = 
    vec![Some(1), Some(2), Some(3)]
        .into_iter()
        .collect();
// Some([1, 2, 3])
</code></pre>
<p><strong>Has None:</strong></p>
<pre><code class="language-rust">let has_none: Option&lt;Vec&lt;i32&gt;&gt; = 
    vec![Some(1), None, Some(3)]
        .into_iter()
        .collect();
// None - one None makes entire result None
</code></pre>
<p><strong>Key behavior:</strong> Transforms <code>Iterator&lt;Item = Result&lt;T, E&gt;&gt;</code> into <code>Result&lt;Vec&lt;T&gt;, E&gt;</code> and <code>Iterator&lt;Item = Option&lt;T&gt;&gt;</code> into <code>Option&lt;Vec&lt;T&gt;&gt;</code>.</p>
<p>This is extremely useful for error propagation in pipelines.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Partition Split Into Two</h2>
<p>What does <code>.partition()</code> do? When would you use it instead of <code>.filter()</code>?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p><code>.partition()</code> splits an iterator into two collections based on a predicate - elements that match and elements that don't.</p>
<p><strong>Signature:</strong></p>
<pre><code class="language-rust">fn partition&lt;B, F&gt;(self, f: F) -&gt; (B, B)
where
    F: FnMut(&amp;Self::Item) -&gt; bool
</code></pre>
<p><strong>Basic usage:</strong></p>
<pre><code class="language-rust">let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

let (evens, odds): (Vec&lt;_&gt;, Vec&lt;_&gt;) = numbers.into_iter()
    .partition(|&amp;n| n % 2 == 0);
// evens: [2, 4, 6, 8, 10]
// odds: [1, 3, 5, 7, 9]
</code></pre>
<p><strong>Separating valid/invalid:</strong></p>
<pre><code class="language-rust">let (valid, invalid): (Vec&lt;_&gt;, Vec&lt;_&gt;) = data.into_iter()
    .partition(|item| item.is_valid());
</code></pre>
<p><strong>With Results:</strong></p>
<pre><code class="language-rust">let results = vec![Ok(1), Err(&quot;e1&quot;), Ok(2), Err(&quot;e2&quot;)];
let (successes, failures): (Vec&lt;_&gt;, Vec&lt;_&gt;) = results.into_iter()
    .partition(|r| r.is_ok());
</code></pre>
<p><strong>When to use:</strong>
- Need BOTH filtered and non-filtered elements
- Processing two separate groups differently
- Error handling where you need both successes and failures</p>
<p><strong>Compared to filter:</strong></p>
<pre><code class="language-rust">// filter - only get one side
let evens: Vec&lt;_&gt; = nums.iter().filter(|&amp;&amp;x| x % 2 == 0).collect();

// partition - get both sides
let (evens, odds) = nums.into_iter().partition(|&amp;x| x % 2 == 0);
</code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Sum and Product Arithmetic</h2>
<p>What do <code>.sum()</code> and <code>.product()</code> do? What trait requirement do they have?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p><code>.sum()</code> adds all elements; <code>.product()</code> multiplies all elements.</p>
<p><strong>Signatures:</strong></p>
<pre><code class="language-rust">fn sum&lt;S&gt;(self) -&gt; S where S: Sum&lt;Self::Item&gt;
fn product&lt;P&gt;(self) -&gt; P where P: Product&lt;Self::Item&gt;
</code></pre>
<p><strong>Basic examples:</strong></p>
<pre><code class="language-rust">// Sum
let total: i32 = vec![1, 2, 3, 4, 5].iter().sum();
// 15

// Product
let factorial: i32 = (1..=5).product();
// 120 (5! = 5 × 4 × 3 × 2 × 1)
</code></pre>
<p><strong>With filtering:</strong></p>
<pre><code class="language-rust">let even_sum: i32 = (1..=10)
    .filter(|x| x % 2 == 0)
    .sum();
// 30 (2 + 4 + 6 + 8 + 10)
</code></pre>
<p><strong>With mapping:</strong></p>
<pre><code class="language-rust">let sum_of_squares: i32 = vec![1, 2, 3, 4, 5]
    .iter()
    .map(|x| x * x)
    .sum();
// 55 (1 + 4 + 9 + 16 + 25)
</code></pre>
<p><strong>Type annotation required:</strong></p>
<pre><code class="language-rust">let total: i32 = iter.sum();  // Must specify type
// or
let total = iter.sum::&lt;i32&gt;();
</code></pre>
<p><strong>Trait requirement:</strong> Types must implement <code>Sum</code> or <code>Product</code> trait (all standard numeric types do: i32, f64, etc.).</p>
<p>These are specialized versions of fold for common arithmetic operations.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Fold Universal Reducer</h2>
<p>Why is <code>.fold()</code> called the "universal reducer"? Show an example beyond simple summation.</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p><code>.fold()</code> can express any reduction operation - it's the most general consumer.</p>
<p><strong>Signature:</strong></p>
<pre><code class="language-rust">fn fold&lt;B, F&gt;(self, init: B, f: F) -&gt; B
where F: FnMut(B, Self::Item) -&gt; B
</code></pre>
<p><strong>Parameters:</strong>
- <code>init</code> - Initial accumulator value
- <code>f</code> - Closure: (accumulator, next_item) → new_accumulator</p>
<p><strong>Beyond summation - building statistics:</strong></p>
<pre><code class="language-rust">#[derive(Debug)]
struct Stats {
    count: usize,
    sum: i32,
    min: i32,
    max: i32,
}

let stats = numbers.iter().fold(
    Stats {
        count: 0,
        sum: 0,
        min: i32::MAX,
        max: i32::MIN,
    },
    |mut acc, &amp;x| {
        acc.count += 1;
        acc.sum += x;
        acc.min = acc.min.min(x);
        acc.max = acc.max.max(x);
        acc
    }
);

let average = stats.sum / stats.count as i32;
</code></pre>
<p><strong>Grouping elements:</strong></p>
<pre><code class="language-rust">let grouped: HashMap&lt;char, Vec&lt;String&gt;&gt; = words.into_iter()
    .fold(HashMap::new(), |mut map, word| {
        let first_char = word.chars().next().unwrap();
        map.entry(first_char)
            .or_insert_with(Vec::new)
            .push(word);
        map
    });
</code></pre>
<p><strong>Why "universal":</strong> Any consuming operation can be expressed as fold - sum, product, collect, max, min, etc. are all specialized folds.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Reduce vs Fold Difference</h2>
<p>How does <code>.reduce()</code> differ from <code>.fold()</code>? When would you use each?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Both reduce iterators to single values, but differ in initial value handling.</p>
<p><strong>Fold - requires initial value:</strong></p>
<pre><code class="language-rust">fn fold&lt;B, F&gt;(self, init: B, f: F) -&gt; B
</code></pre>
<pre><code class="language-rust">let sum = vec![1, 2, 3, 4].iter()
    .fold(0, |acc, &amp;x| acc + x);
// 10
</code></pre>
<p><strong>Reduce - uses first element:</strong></p>
<pre><code class="language-rust">fn reduce&lt;F&gt;(self, f: F) -&gt; Option&lt;Self::Item&gt;
</code></pre>
<pre><code class="language-rust">let max = vec![3, 7, 2, 9, 1].into_iter()
    .reduce(|a, b| a.max(b));
// Some(9)
</code></pre>
<p><strong>Key differences:</strong></p>
<p>| Aspect | fold | reduce |
|--------|------|--------|
| Initial value | Required | Uses first element |
| Return type | <code>B</code> | <code>Option&lt;Item&gt;</code> |
| Empty iterator | Returns init | Returns None |
| Type flexibility | Can change type | Same type |</p>
<p><strong>Empty iterator behavior:</strong></p>
<pre><code class="language-rust">// fold with empty
let sum = Vec::&lt;i32&gt;::new().iter().fold(0, |acc, &amp;x| acc + x);
// 0 (returns init)

// reduce with empty
let max = Vec::&lt;i32&gt;::new().into_iter().reduce(|a, b| a.max(b));
// None
</code></pre>
<p><strong>Use fold when:</strong>
- Need specific initial value
- Accumulator type differs from item type
- Empty iterator should return meaningful default</p>
<p><strong>Use reduce when:</strong>
- First element is natural starting point
- Same type for accumulator and items
- Empty iterator should be None</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Find First Match</h2>
<p>What does <code>.find()</code> do? How does it perform on large iterators and infinite iterators?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p><code>.find()</code> returns the first element matching a predicate, short-circuiting on match.</p>
<p><strong>Signature:</strong></p>
<pre><code class="language-rust">fn find&lt;P&gt;(self, predicate: P) -&gt; Option&lt;Self::Item&gt;
where P: FnMut(&amp;Self::Item) -&gt; bool
</code></pre>
<p><strong>Basic usage:</strong></p>
<pre><code class="language-rust">let numbers = vec![1, 3, 5, 6, 7, 9];

let first_even = numbers.iter()
    .find(|&amp;&amp;x| x % 2 == 0);
// Some(&amp;6)

let first_big = numbers.iter()
    .find(|&amp;&amp;x| x &gt; 100);
// None
</code></pre>
<p><strong>Short-circuits - critical for performance:</strong></p>
<pre><code class="language-rust">// Only checks until match found
let found = (0..1_000_000)
    .find(|&amp;x| x == 500);
// Some(500) - stops immediately, doesn't check 999,500 remaining
</code></pre>
<p><strong>Works with infinite iterators:</strong></p>
<pre><code class="language-rust">let first_big = (0..)  // Infinite iterator
    .find(|&amp;x| x &gt; 1000);
// Some(1001) - stops and returns, doesn't hang
</code></pre>
<p><strong>With complex predicates:</strong></p>
<pre><code class="language-rust">let user = users.iter()
    .find(|u| u.email == target &amp;&amp; u.is_active);
</code></pre>
<p><strong>Returns element, not index:</strong></p>
<pre><code class="language-rust">// find returns the element
let element: Option&lt;&amp;i32&gt; = numbers.iter().find(predicate);

// Use position() for index
let index: Option&lt;usize&gt; = numbers.iter().position(predicate);
</code></pre>
<p>Performance: O(n) worst case, but short-circuits mean average case is often much better.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Position vs Find</h2>
<p>What's the difference between <code>.position()</code> and <code>.find()</code>? When would you use each?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Both search for elements matching a predicate, but return different information.</p>
<p><strong>Find - returns the element:</strong></p>
<pre><code class="language-rust">fn find&lt;P&gt;(self, predicate: P) -&gt; Option&lt;Self::Item&gt;
</code></pre>
<pre><code class="language-rust">let first_even = numbers.iter()
    .find(|&amp;&amp;x| x % 2 == 0);
// Some(&amp;6) - returns reference to element
</code></pre>
<p><strong>Position - returns the index:</strong></p>
<pre><code class="language-rust">fn position&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;usize&gt;
</code></pre>
<pre><code class="language-rust">let position = numbers.iter()
    .position(|&amp;x| x % 2 == 0);
// Some(3) - returns index where found
</code></pre>
<p><strong>Comparison:</strong></p>
<p>| Method | Returns | Use when |
|--------|---------|----------|
| <code>.find()</code> | <code>Option&lt;Item&gt;</code> | Need the value itself |
| <code>.position()</code> | <code>Option&lt;usize&gt;</code> | Need the index/location |</p>
<p><strong>Using position for indexing:</strong></p>
<pre><code class="language-rust">if let Some(pos) = numbers.iter().position(|&amp;x| x == target) {
    println!(&quot;Found at index {}&quot;, pos);
    let value = &amp;numbers[pos];  // Can index with result
}
</code></pre>
<p><strong>Find for immediate use:</strong></p>
<pre><code class="language-rust">if let Some(user) = users.iter().find(|u| u.id == target_id) {
    process_user(user);  // Have the actual user
}
</code></pre>
<p><strong>Both short-circuit</strong> - stop at first match for efficiency.</p>
<p>Choose based on what you need: the element itself or its position.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Any and All Testing</h2>
<p>What do <code>.any()</code> and <code>.all()</code> do? How do they short-circuit, and what's their relationship?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Test predicates across iterators, returning boolean results with short-circuiting.</p>
<p><strong>Any - true if ANY element matches:</strong></p>
<pre><code class="language-rust">fn any&lt;F&gt;(&amp;mut self, f: F) -&gt; bool
where F: FnMut(Self::Item) -&gt; bool
</code></pre>
<pre><code class="language-rust">let has_even = vec![1, 3, 5, 6, 9].iter()
    .any(|&amp;x| x % 2 == 0);
// true (6 is even - stops checking after finding it)
</code></pre>
<p><strong>All - true if ALL elements match:</strong></p>
<pre><code class="language-rust">fn all&lt;F&gt;(&amp;mut self, f: F) -&gt; bool
where F: FnMut(Self::Item) -&gt; bool
</code></pre>
<pre><code class="language-rust">let all_positive = vec![1, 2, 3, 4].iter()
    .all(|&amp;x| x &gt; 0);
// true

let all_positive = vec![1, 2, -3, 4].iter()
    .all(|&amp;x| x &gt; 0);
// false (stops at -3, doesn't check 4)
</code></pre>
<p><strong>Short-circuiting:</strong>
- <code>.any()</code> stops at first <code>true</code>
- <code>.all()</code> stops at first <code>false</code></p>
<pre><code class="language-rust">// Only checks 0-101, not all million
(0..1_000_000).any(|x| x &gt; 100)  // true

// Only checks 0-2, stops at -3
vec![1, 2, -3, 4, 5].iter().all(|&amp;x| x &gt; 0)  // false
</code></pre>
<p><strong>Relationship (De Morgan's laws):</strong></p>
<pre><code class="language-rust">// These are equivalent
!iter.any(|x| condition(x))
iter.all(|x| !condition(x))

// And
!iter.all(|x| condition(x))
iter.any(|x| !condition(x))
</code></pre>
<p><strong>Edge case - empty iterator:</strong></p>
<pre><code class="language-rust">Vec::&lt;i32&gt;::new().iter().any(|&amp;x| x &gt; 0)  // false
Vec::&lt;i32&gt;::new().iter().all(|&amp;x| x &gt; 0)  // true (vacuous truth)
</code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Nth Element Extraction</h2>
<p>How does <code>.nth()</code> work? What's the critical gotcha about its index parameter?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p><code>.nth(n)</code> returns element at index n, but the index is <strong>relative to current position</strong>, not absolute from start.</p>
<p><strong>Signature:</strong></p>
<pre><code class="language-rust">fn nth(&amp;mut self, n: usize) -&gt; Option&lt;Self::Item&gt;
</code></pre>
<p><strong>Critical gotcha - relative indexing:</strong></p>
<pre><code class="language-rust">let mut iter = vec![10, 20, 30, 40, 50].into_iter();

let third = iter.nth(2);  // Gets index 2 from START
// Some(30)

let next = iter.nth(0);   // Gets index 0 from CURRENT position
// Some(40) - NOT 10!

// iter.nth(3) would be WRONG here - it would skip ahead
</code></pre>
<p><strong>What's happening:</strong></p>
<pre><code class="language-rust">let mut iter = (0..10);

iter.nth(5);  // Consumes 0,1,2,3,4,5 → returns 5
              // Now at position after 5

iter.nth(0);  // Next element → returns 6
iter.nth(2);  // Skips 7,8 → returns 9
</code></pre>
<p><strong>Mental model:</strong> <code>.nth(n)</code> means "skip n elements, return the next one"</p>
<p><strong>Consuming behavior:</strong></p>
<pre><code class="language-rust">// Each call consumes elements
let mut iter = (0..10);
iter.nth(2);   // Consumes 0,1,2
iter.nth(2);   // Consumes 3,4,5 (not 2 from start!)
iter.nth(2);   // Consumes 6,7,8
iter.nth(0);   // Returns 9
iter.nth(0);   // None - exhausted
</code></pre>
<p><strong>Using for skipping:</strong></p>
<pre><code class="language-rust">let mut iter = large_dataset.into_iter();
iter.nth(99);  // Skip first 100 elements (discard result)
// Now at element 100
</code></pre>
<p><strong>Better alternative for absolute indexing:</strong></p>
<pre><code class="language-rust">let third = vec[2];  // Direct indexing if you have slice
// or
let third = vec.iter().skip(2).next();
</code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Last Element Extraction</h2>
<p>What does <code>.last()</code> do? What's its performance characteristic?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p><code>.last()</code> returns the last element by consuming the entire iterator.</p>
<p><strong>Signature:</strong></p>
<pre><code class="language-rust">fn last(self) -&gt; Option&lt;Self::Item&gt;
</code></pre>
<p><strong>Basic usage:</strong></p>
<pre><code class="language-rust">let last = vec![1, 2, 3, 4, 5].into_iter().last();
// Some(5)

let empty: Vec&lt;i32&gt; = vec![];
let none = empty.into_iter().last();
// None
</code></pre>
<p><strong>With filtering:</strong></p>
<pre><code class="language-rust">let last_even = (1..=100)
    .filter(|x| x % 2 == 0)
    .last();
// Some(100)
</code></pre>
<p><strong>Performance: O(n) - must iterate through everything</strong></p>
<pre><code class="language-rust">// This iterates through ALL elements to get last
huge_vec.iter().last()

// More efficient if you have direct access
let last = huge_vec.last()  // O(1) for Vec
</code></pre>
<p><strong>When to use:</strong>
- Don't have direct access to underlying collection
- Working with iterator chain
- After filtering/mapping</p>
<p><strong>When NOT to use:</strong>
- Have a Vec/slice: use <code>vec.last()</code> directly
- Need index too: use <code>vec.len() - 1</code></p>
<p><strong>Doesn't short-circuit:</strong></p>
<pre><code class="language-rust">// Processes ENTIRE range even though we only want last
(0..1_000_000)
    .map(expensive_operation)
    .last();  // Performs 1 million operations!
</code></pre>
<p>Unlike <code>.find()</code> or <code>.any()</code>, <code>.last()</code> must consume everything.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Max and Min Extremes</h2>
<p>What do <code>.max()</code> and <code>.min()</code> do? What trait requirement do they have, and how do you handle floats?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p><code>.max()</code> and <code>.min()</code> find the maximum or minimum element.</p>
<p><strong>Signatures:</strong></p>
<pre><code class="language-rust">fn max(self) -&gt; Option&lt;Self::Item&gt;
where Self::Item: Ord

fn min(self) -&gt; Option&lt;Self::Item&gt;
where Self::Item: Ord
</code></pre>
<p><strong>Basic usage:</strong></p>
<pre><code class="language-rust">let numbers = vec![3, 7, 2, 9, 1];

let max = numbers.iter().max();
// Some(&amp;9)

let min = numbers.iter().min();
// Some(&amp;1)
</code></pre>
<p><strong>Trait requirement: <code>Ord</code> (total ordering)</strong>
- Works: integers, strings, chars
- Doesn't work: floats (no Ord due to NaN)</p>
<p><strong>Handling floats - use fold:</strong></p>
<pre><code class="language-rust">let floats = vec![3.5, 7.2, 2.1, 9.8, 1.4];

// Can't use .max() directly on floats
// let max = floats.iter().max();  // ERROR: no Ord

// Use fold instead
let max = floats.iter()
    .fold(f64::NEG_INFINITY, |a, &amp;b| a.max(b));
// 9.8

let min = floats.iter()
    .fold(f64::INFINITY, |a, &amp;b| a.min(b));
// 1.4
</code></pre>
<p><strong>Custom comparison with max_by_key:</strong></p>
<pre><code class="language-rust">let people = vec![
    Person { name: &quot;Alice&quot;, age: 30 },
    Person { name: &quot;Bob&quot;, age: 25 },
    Person { name: &quot;Carol&quot;, age: 35 },
];

let oldest = people.iter().max_by_key(|p| p.age);
// Some(&amp;Person { name: &quot;Carol&quot;, age: 35 })

let longest_name = people.iter().max_by_key(|p| p.name.len());
</code></pre>
<p><strong>Empty iterator:</strong></p>
<pre><code class="language-rust">Vec::&lt;i32&gt;::new().iter().max()  // None
</code></pre>
<p>Performance: O(n) - must check every element.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Count Elements</h2>
<p>What does <code>.count()</code> do? When is it more efficient than <code>.len()</code>?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p><code>.count()</code> returns the number of elements in an iterator.</p>
<p><strong>Signature:</strong></p>
<pre><code class="language-rust">fn count(self) -&gt; usize
</code></pre>
<p><strong>Basic usage:</strong></p>
<pre><code class="language-rust">let count = vec![1, 2, 3, 4, 5].iter().count();
// 5

let even_count = (1..=100)
    .filter(|x| x % 2 == 0)
    .count();
// 50
</code></pre>
<p><strong>After transformations:</strong></p>
<pre><code class="language-rust">let valid_count = data.iter()
    .filter(|x| x.is_valid())
    .map(|x| x.process())
    .count();
</code></pre>
<p><strong>Performance: O(n) - must iterate through everything</strong></p>
<pre><code class="language-rust">// This processes every element
huge_data.iter()
    .filter(predicate)
    .map(transform)
    .count();
</code></pre>
<p><strong>When to use <code>.count()</code> vs <code>.len()</code>:</strong></p>
<p><strong>Use <code>.len()</code> when available (O(1)):</strong></p>
<pre><code class="language-rust">let count = vec.len();  // Instant - stored in Vec
</code></pre>
<p><strong>Use <code>.count()</code> when:</strong>
- Working with iterator chain
- After filtering/mapping
- Don't have direct collection access
- Iterator doesn't implement ExactSizeIterator</p>
<p><strong>Comparison:</strong></p>
<pre><code class="language-rust">// Efficient
vec![1, 2, 3, 4, 5].len()  // O(1)

// Less efficient but necessary
vec![1, 2, 3, 4, 5].iter()
    .filter(|&amp;&amp;x| x % 2 == 0)
    .count()  // O(n) - must check each element
</code></pre>
<p><strong>Checking emptiness:</strong></p>
<pre><code class="language-rust">// Less efficient
if data.iter().count() &gt; 0 { }

// More efficient
if !data.is_empty() { }

// Or for iterators
if data.iter().next().is_some() { }
</code></pre>
<p><code>.count()</code> is necessary for iterators but prefer <code>.len()</code> when available.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>For Each Side Effects</h2>
<p>What is <code>.for_each()</code> used for? How does it compare to a <code>for</code> loop?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p><code>.for_each()</code> executes a closure on each element for side effects only.</p>
<p><strong>Signature:</strong></p>
<pre><code class="language-rust">fn for_each&lt;F&gt;(self, f: F)
where F: FnMut(Self::Item)
</code></pre>
<p><strong>Basic usage:</strong></p>
<pre><code class="language-rust">vec![1, 2, 3].iter().for_each(|x| println!(&quot;{}&quot;, x));

// Multiple operations
data.iter().for_each(|item| {
    log::info!(&quot;Processing: {:?}&quot;, item);
    process(item);
    update_metrics();
});
</code></pre>
<p><strong>Compared to for loop:</strong></p>
<p><strong>With <code>.for_each()</code> (method):</strong></p>
<pre><code class="language-rust">data.iter()
    .filter(|x| x.is_valid())
    .for_each(|x| process(x));
</code></pre>
<p><strong>With <code>for</code> loop (statement):</strong></p>
<pre><code class="language-rust">for x in data.iter().filter(|x| x.is_valid()) {
    process(x);
}
</code></pre>
<p><strong>Both have identical performance</strong> - compiler generates same code.</p>
<p><strong>When to use <code>.for_each()</code>:</strong>
- Part of iterator chain (method style)
- More functional/declarative style
- When it reads better</p>
<p><strong>When to use <code>for</code> loop:</strong>
- Need early <code>break</code> or <code>continue</code>
- Complex control flow
- Multiple statements are clearer
- Traditional imperative style</p>
<p><strong>Differences:</strong></p>
<p>| Feature | .for_each() | for loop |
|---------|-------------|----------|
| Style | Method/functional | Statement/imperative |
| Early exit | Can't break | Can break/continue |
| Return value | None | Can return from loop |
| Chaining | Natural | Requires separate line |</p>
<p><strong>Example where for loop is better:</strong></p>
<pre><code class="language-rust">// Can't do this with .for_each()
for item in data.iter() {
    if item.should_stop() {
        break;  // Early exit
    }
    process(item);
}
</code></pre>
<p>Use <code>.for_each()</code> when you truly want to perform an action on every element without early termination.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Consumer Execution Trigger</h2>
<p>Why are consumers called "execution triggers"? Show what happens without a consumer.</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Consumers trigger execution because adaptors are lazy and do nothing until consumed.</p>
<p><strong>Without consumer - nothing happens:</strong></p>
<pre><code class="language-rust">// BUG: No execution!
vec![1, 2, 3].iter().map(|x| {
    println!(&quot;Processing {}&quot;, x);  // NEVER PRINTS
    x * 2
});

// Compiler warning: &quot;unused `Map` that must be used&quot;
</code></pre>
<p><strong>What's created:</strong></p>
<pre><code class="language-rust">// Just builds a type structure
let _unused = vec![1, 2, 3].iter()
    .filter(|&amp;&amp;x| x &gt; 0)
    .map(|&amp;x| x * 2);
// Type: Map&lt;Filter&lt;Iter&lt;i32&gt;&gt;&gt; - but .next() never called!
</code></pre>
<p><strong>Adding consumer - triggers execution:</strong></p>
<pre><code class="language-rust">vec![1, 2, 3].iter()
    .map(|x| {
        println!(&quot;Processing {}&quot;, x);  // NOW PRINTS
        x * 2
    })
    .collect::&lt;Vec&lt;_&gt;&gt;();  // CONSUMER - makes it run!
</code></pre>
<p><strong>How consumers trigger execution:</strong></p>
<ol>
<li>Consumer calls <code>.next()</code> on the iterator</li>
<li>That cascades through all adaptors</li>
<li>Each element flows through the entire pipeline</li>
<li>Continues until iterator exhausted</li>
</ol>
<p><strong>Different consumers, same trigger:</strong></p>
<pre><code class="language-rust">// All of these trigger execution:
iter.collect::&lt;Vec&lt;_&gt;&gt;();
iter.sum();
iter.for_each(|x| process(x));
iter.any(|x| x &gt; 10);
iter.count();

// None of these trigger execution:
iter.filter(|x| x &gt; 0)
iter.map(|x| x * 2)
iter.take(10)
</code></pre>
<p><strong>Mental model:</strong>
- Adaptors = Recipe instructions (dormant)
- Consumers = Chef executing recipe (active)</p>
<p>Without a consumer, you've written a recipe but no one cooks the meal.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Short Circuiting Consumers</h2>
<p>Which consumers short-circuit? Why is this important for performance?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Short-circuiting consumers stop processing as soon as the answer is known.</p>
<p><strong>Short-circuiting consumers:</strong></p>
<p><strong>1. <code>.find()</code> - stops at first match:</strong></p>
<pre><code class="language-rust">let found = (0..1_000_000)
    .find(|&amp;x| x == 500);
// Stops at 500, doesn't check remaining 999,500 elements
</code></pre>
<p><strong>2. <code>.any()</code> - stops at first true:</strong></p>
<pre><code class="language-rust">let has_even = vec![1, 3, 5, 6, 9, 11, 13].iter()
    .any(|&amp;x| x % 2 == 0);
// Stops at 6, doesn't check 9, 11, 13
</code></pre>
<p><strong>3. <code>.all()</code> - stops at first false:</strong></p>
<pre><code class="language-rust">let all_positive = vec![1, 2, -3, 4, 5].iter()
    .all(|&amp;x| x &gt; 0);
// Stops at -3, doesn't check 4, 5
</code></pre>
<p><strong>4. <code>.position()</code> - stops at first match:</strong></p>
<pre><code class="language-rust">let pos = (0..1_000_000)
    .position(|x| x &gt; 1000);
// Stops at 1001
</code></pre>
<p><strong>Non-short-circuiting consumers (must check all):</strong>
- <code>.collect()</code> - needs all elements
- <code>.sum()</code>, <code>.product()</code> - needs all for arithmetic
- <code>.count()</code> - must count everything
- <code>.last()</code> - must get to the end</p>
<p><strong>Performance impact:</strong></p>
<p><strong>With short-circuiting:</strong></p>
<pre><code class="language-rust">// Only processes until condition met
huge_dataset.iter()
    .map(expensive_operation)
    .any(|x| x.is_target());
// Stops immediately when target found
</code></pre>
<p><strong>Without short-circuiting:</strong></p>
<pre><code class="language-rust">// Processes EVERYTHING
huge_dataset.iter()
    .map(expensive_operation)
    .collect::&lt;Vec&lt;_&gt;&gt;();
// Must process all elements
</code></pre>
<p><strong>Critical for infinite iterators:</strong></p>
<pre><code class="language-rust">// Works - short-circuits
(0..).find(|&amp;x| x &gt; 1000)  // Some(1001)

// Would hang forever
// (0..).collect::&lt;Vec&lt;_&gt;&gt;()  // INFINITE LOOP
</code></pre>
<p><strong>Optimization tip:</strong> Use short-circuiting consumers when possible:</p>
<pre><code class="language-rust">// Inefficient
if data.iter().filter(predicate).count() &gt; 0 { }

// Efficient
if data.iter().any(predicate) { }
</code></pre>
<p>Short-circuiting is the difference between checking millions of elements and checking just a few.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Consumer Ownership</h2>
<p>Why can't you use an iterator after calling a consumer? What's the ownership rule?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Consumers take ownership of the iterator (<code>self</code>), making it unavailable after use.</p>
<p><strong>The problem:</strong></p>
<pre><code class="language-rust">let iter = vec![1, 2, 3].iter();

let sum: i32 = iter.sum();  // Consumes iter
// let count = iter.count();  // ERROR: value used after move
</code></pre>
<p><strong>Error message:</strong></p>
<pre><code>error[E0382]: use of moved value: `iter`
  |
  | let sum: i32 = iter.sum();
  |                ---- value moved here
  | let count = iter.count();
  |             ^^^^ value used here after move
</code></pre>
<p><strong>Why this happens - signature:</strong></p>
<pre><code class="language-rust">// Consumer takes self (not &amp;self)
fn sum&lt;S&gt;(self) -&gt; S  // Takes ownership!

// Compare to adaptor
fn map&lt;F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt;  // Also takes self, but returns iterator
</code></pre>
<p><strong>Solution 1: Create multiple iterators from source:</strong></p>
<pre><code class="language-rust">let vec = vec![1, 2, 3];

let sum: i32 = vec.iter().sum();
let count = vec.iter().count();
let max = vec.iter().max();
// Each creates new iterator from vec
</code></pre>
<p><strong>Solution 2: Clone the iterator (if possible):</strong></p>
<pre><code class="language-rust">let iter = vec.iter();

let sum: i32 = iter.clone().sum();
let count = iter.count();  // Original still available
</code></pre>
<p><strong>Solution 3: Collect first, then reuse:</strong></p>
<pre><code class="language-rust">let processed: Vec&lt;_&gt; = source.iter()
    .filter(predicate)
    .map(transform)
    .collect();

// Now can do multiple operations
let sum = processed.iter().sum();
let count = processed.len();
let max = processed.iter().max();
</code></pre>
<p><strong>Why ownership is taken:</strong>
Consumers genuinely consume the iterator - they might need to drain it completely, and leaving it in an intermediate state would be problematic.</p>
<p><strong>Mental model:</strong> Consumers are terminal - they end the chain by consuming it.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Choosing Right Consumer</h2>
<p>Show examples of inefficient consumer choices and their efficient alternatives.</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Choosing the right consumer significantly impacts performance and code clarity.</p>
<p><strong>Inefficient: Using collect when you need boolean</strong></p>
<pre><code class="language-rust">// BAD - unnecessary allocation
let has_valid = data.iter()
    .filter(|x| x.is_valid())
    .collect::&lt;Vec&lt;_&gt;&gt;()
    .len() &gt; 0;

// GOOD - short-circuits
let has_valid = data.iter()
    .any(|x| x.is_valid());
</code></pre>
<p><strong>Inefficient: Collecting then counting</strong></p>
<pre><code class="language-rust">// BAD - allocates vector unnecessarily
let count = data.iter()
    .filter(predicate)
    .collect::&lt;Vec&lt;_&gt;&gt;()
    .len();

// GOOD - just counts
let count = data.iter()
    .filter(predicate)
    .count();
</code></pre>
<p><strong>Inefficient: Collecting to check emptiness</strong></p>
<pre><code class="language-rust">// BAD - processes all elements
if data.iter().collect::&lt;Vec&lt;_&gt;&gt;().is_empty() { }

// GOOD - checks just first element
if data.iter().next().is_none() { }

// EVEN BETTER - direct check if available
if data.is_empty() { }
</code></pre>
<p><strong>Inefficient: Manual fold for sum/product</strong></p>
<pre><code class="language-rust">// BAD - verbose and harder to read
let sum = data.iter().fold(0, |acc, &amp;x| acc + x);

// GOOD - specialized consumer
let sum: i32 = data.iter().sum();
</code></pre>
<p><strong>Inefficient: Collecting when you need one element</strong></p>
<pre><code class="language-rust">// BAD - processes everything, allocates
let first_valid = data.iter()
    .filter(is_valid)
    .collect::&lt;Vec&lt;_&gt;&gt;()[0];

// GOOD - stops at first
let first_valid = data.iter()
    .find(is_valid)
    .unwrap();
</code></pre>
<p><strong>Inefficient: Multiple collects for multiple consumers</strong></p>
<pre><code class="language-rust">// BAD - processes chain multiple times
let vec1: Vec&lt;_&gt; = source.iter().filter(p).collect();
let vec2: Vec&lt;_&gt; = source.iter().filter(p).collect();

// GOOD - process once, clone source
let filtered: Vec&lt;_&gt; = source.iter().filter(p).collect();
let vec1 = filtered.clone();
let vec2 = filtered;
</code></pre>
<p><strong>Decision tree:</strong>
- Need all elements in collection → <code>.collect()</code>
- Need single numeric value → <code>.sum()</code>, <code>.product()</code>, <code>.fold()</code>
- Need to find element → <code>.find()</code>, <code>.position()</code>
- Need boolean test → <code>.any()</code>, <code>.all()</code>
- Need count → <code>.count()</code>
- Need side effects only → <code>.for_each()</code></p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Collect Error Handling Pattern</h2>
<p>Show the pattern for collecting Results with error handling, including both "stop at first error" and "collect all errors" approaches.</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Different patterns for handling errors when collecting Results.</p>
<p><strong>Pattern 1: Stop at first error</strong></p>
<pre><code class="language-rust">// Returns Result&lt;Vec&lt;T&gt;, E&gt;
let results: Result&lt;Vec&lt;i32&gt;, _&gt; = inputs.iter()
    .map(|input| process_with_error(input))
    .collect();

match results {
    Ok(values) =&gt; println!(&quot;All succeeded: {:?}&quot;, values),
    Err(e) =&gt; println!(&quot;Failed at first error: {}&quot;, e),
}
</code></pre>
<p><strong>Pattern 2: Separate successes and failures</strong></p>
<pre><code class="language-rust">let (successes, failures): (Vec&lt;_&gt;, Vec&lt;_&gt;) = inputs.iter()
    .map(|input| process_with_error(input))
    .partition(Result::is_ok);

let successes: Vec&lt;T&gt; = successes.into_iter()
    .map(Result::unwrap)
    .collect();

let errors: Vec&lt;E&gt; = failures.into_iter()
    .map(Result::unwrap_err)
    .collect();
</code></pre>
<p><strong>Pattern 3: Filter to only successes</strong></p>
<pre><code class="language-rust">let successes: Vec&lt;T&gt; = inputs.iter()
    .map(|input| process_with_error(input))
    .filter_map(Result::ok)
    .collect();
// Discards all errors
</code></pre>
<p><strong>Pattern 4: Collect all errors if any</strong></p>
<pre><code class="language-rust">let results: Vec&lt;Result&lt;T, E&gt;&gt; = inputs.iter()
    .map(|input| process_with_error(input))
    .collect();

let has_errors = results.iter().any(Result::is_err);
if has_errors {
    let errors: Vec&lt;_&gt; = results.iter()
        .filter_map(|r| r.as_ref().err())
        .collect();
    return Err(MultipleErrors(errors));
}

let values: Vec&lt;T&gt; = results.into_iter()
    .map(Result::unwrap)
    .collect();
</code></pre>
<p><strong>Pattern 5: Accumulate errors with fold</strong></p>
<pre><code class="language-rust">let (values, errors): (Vec&lt;T&gt;, Vec&lt;E&gt;) = inputs.iter()
    .map(|input| process_with_error(input))
    .fold((Vec::new(), Vec::new()), |(mut ok, mut err), result| {
        match result {
            Ok(v) =&gt; ok.push(v),
            Err(e) =&gt; err.push(e),
        }
        (ok, err)
    });

if !errors.is_empty() {
    // Handle errors
}
</code></pre>
<p><strong>Key insight:</strong> <code>.collect()</code> on <code>Result</code> automatically implements "stop at first error" semantics. For other behaviors, use <code>partition</code>, <code>filter_map</code>, or <code>fold</code>.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Find Map Combined Search</h2>
<p>What does <code>.find_map()</code> do? When is it more efficient than <code>.find().map()</code>?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p><code>.find_map()</code> combines finding and transforming into one operation, returning <code>Option</code>.</p>
<p><strong>Signature:</strong></p>
<pre><code class="language-rust">fn find_map&lt;B, F&gt;(self, f: F) -&gt; Option&lt;B&gt;
where F: FnMut(Self::Item) -&gt; Option&lt;B&gt;
</code></pre>
<p><strong>How it works:</strong>
- Closure returns <code>Some(value)</code> → found and transformed
- Closure returns <code>None</code> → keep searching</p>
<p><strong>Efficient - single evaluation:</strong></p>
<pre><code class="language-rust">let result = data.iter()
    .find_map(|item| {
        if item.is_valid() {
            Some(item.expensive_transform())
        } else {
            None
        }
    });
</code></pre>
<p><strong>Less efficient - evaluates twice:</strong></p>
<pre><code class="language-rust">let result = data.iter()
    .find(|item| item.is_valid())
    .map(|item| item.expensive_transform());
</code></pre>
<p><strong>Pattern matching in find_map:</strong></p>
<pre><code class="language-rust">enum Status { Active(u32), Inactive, Pending(u32) }

let first_active_id = statuses.iter()
    .find_map(|status| match status {
        Status::Active(id) =&gt; Some(*id),
        Status::Pending(id) =&gt; Some(*id),
        Status::Inactive =&gt; None,
    });
</code></pre>
<p><strong>Parsing with early success:</strong></p>
<pre><code class="language-rust">let first_valid_number = strings.iter()
    .find_map(|s| s.parse::&lt;i32&gt;().ok());
// Returns first successfully parsed number
</code></pre>
<p><strong>Database lookup:</strong></p>
<pre><code class="language-rust">let user = user_ids.iter()
    .find_map(|id| database.get_user(id));
// Returns first found user
</code></pre>
<p><strong>Why it's better:</strong>
1. <strong>Single evaluation</strong> - expensive operation runs only if condition met
2. <strong>Short-circuits</strong> - stops at first Some
3. <strong>More expressive</strong> - combines condition and extraction</p>
<p><strong>Use when:</strong>
- Searching with transformation
- Operation is expensive
- Pattern matching with extraction
- Working with Option/Result chains</p>
<p>Equivalent to <code>.filter_map().next()</code> but more semantic.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Try Fold Error Propagation</h2>
<p>What does <code>.try_fold()</code> do? How does it differ from regular <code>.fold()</code>?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p><code>.try_fold()</code> is like <code>.fold()</code> but can short-circuit on error, returning <code>Result</code>.</p>
<p><strong>Signature:</strong></p>
<pre><code class="language-rust">fn try_fold&lt;B, F, R&gt;(&amp;mut self, init: B, f: F) -&gt; R
where
    F: FnMut(B, Self::Item) -&gt; R,
    R: Try&lt;Output = B&gt;
</code></pre>
<p><strong>Regular fold - no early exit:</strong></p>
<pre><code class="language-rust">let sum = numbers.iter()
    .fold(0, |acc, &amp;x| {
        acc + x
    });
// Must process all elements
</code></pre>
<p><strong>Try fold - can fail and stop:</strong></p>
<pre><code class="language-rust">let result: Result&lt;i32, Error&gt; = numbers.iter()
    .try_fold(0, |acc, &amp;x| {
        if x &lt; 0 {
            Err(Error::NegativeNumber)
        } else {
            Ok(acc + x)
        }
    });
// Stops at first error
</code></pre>
<p><strong>Validating while accumulating:</strong></p>
<pre><code class="language-rust">let validated_sum: Result&lt;i32, String&gt; = inputs.iter()
    .try_fold(0, |acc, input| {
        let value = input.parse::&lt;i32&gt;()
            .map_err(|_| format!(&quot;Invalid: {}&quot;, input))?;
        Ok(acc + value)
    });
</code></pre>
<p><strong>Building with fallible operations:</strong></p>
<pre><code class="language-rust">let result: Result&lt;Vec&lt;Item&gt;, Error&gt; = data.iter()
    .try_fold(Vec::new(), |mut acc, elem| {
        let processed = elem.try_process()?;
        acc.push(processed);
        Ok(acc)
    });
</code></pre>
<p><strong>Key differences from fold:</strong></p>
<p>| Aspect | fold | try_fold |
|--------|------|----------|
| Return type | <code>B</code> | <code>Result&lt;B, E&gt;</code> or <code>Option&lt;B&gt;</code> |
| Early exit | No | Yes (on Err/None) |
| Error handling | Can't propagate | Can propagate with <code>?</code> |</p>
<p><strong>Works with Option too:</strong></p>
<pre><code class="language-rust">let first_negative: Option&lt;i32&gt; = numbers.iter()
    .try_fold((), |_, &amp;x| {
        if x &lt; 0 {
            None  // Stop and return None
        } else {
            Some(())  // Continue
        }
    })
    .map(|_| None)
    .unwrap_or_else(|| Some(/* found */));
</code></pre>
<p><strong>Use when:</strong>
- Accumulation can fail
- Need error propagation
- Want early termination on error
- Building fallible structures</p>
<p>More powerful than fold when dealing with errors.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Consumer Performance Comparison</h2>
<p>Compare the performance characteristics of different consumers. Which are O(n) and which can short-circuit?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Consumer performance varies significantly based on whether they can stop early.</p>
<p><strong>O(n) - Must check every element:</strong></p>
<p><strong>Collection builders:</strong></p>
<pre><code class="language-rust">.collect()        // O(n) - must get all elements
.partition()      // O(n) - must check each for both sides
.unzip()         // O(n) - must separate all pairs
</code></pre>
<p><strong>Full reducers:</strong></p>
<pre><code class="language-rust">.fold()          // O(n) - processes all elements
.sum()           // O(n) - must add everything
.product()       // O(n) - must multiply everything
.count()         // O(n) - must count all
</code></pre>
<p><strong>Extractors requiring full iteration:</strong></p>
<pre><code class="language-rust">.last()          // O(n) - must get to end
.max()           // O(n) - must check each
.min()           // O(n) - must check each
</code></pre>
<p><strong>O(1) to O(n) - Can short-circuit:</strong></p>
<p><strong>Searchers:</strong></p>
<pre><code class="language-rust">.find()          // O(n) worst, O(1) best - stops at match
.position()      // O(n) worst, O(1) best - stops at match
.any()           // O(n) worst, O(1) best - stops at first true
.all()           // O(n) worst, O(1) best - stops at first false
</code></pre>
<p><strong>Element extractors:</strong></p>
<pre><code class="language-rust">.nth(0)          // O(1) - just first element
.nth(n)          // O(n) - must skip n elements
</code></pre>
<p><strong>Performance comparison example:</strong></p>
<pre><code class="language-rust">let huge_data: Vec&lt;_&gt; = (0..1_000_000).collect();

// Fast - short-circuits at element 101
huge_data.iter().any(|&amp;x| x &gt; 100);  
// Checks: 101 elements

// Slow - must check everything
huge_data.iter().count();
// Checks: 1,000,000 elements

// Medium - stops when found
huge_data.iter().find(|&amp;&amp;x| x == 50000);
// Checks: ~50,001 elements
</code></pre>
<p><strong>Critical for infinite iterators:</strong></p>
<pre><code class="language-rust">// Works - short-circuits
(0..).any(|x| x &gt; 1000);  // Some(1001)

// Works - short-circuits  
(0..).find(|&amp;x| x == 5000);  // Some(5000)

// Hangs forever - no short-circuit
// (0..).count();  // INFINITE LOOP
// (0..).sum();    // INFINITE LOOP
</code></pre>
<p><strong>Optimization strategy:</strong>
1. Use short-circuiting consumers when possible
2. Filter/limit before non-short-circuiting consumers
3. Consider order in complex chains</p>
<pre><code class="language-rust">// Better - limits then counts
huge_data.iter()
    .filter(predicate)
    .take(1000)  // Limit first
    .count();

// vs. counting first (can't limit)
</code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Multiple Aggregations Pattern</h2>
<p>Show how to compute multiple aggregations in a single pass through an iterator using fold.</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Use fold with a tuple or struct to compute multiple values in one iteration.</p>
<p><strong>Pattern 1: Tuple accumulator</strong></p>
<pre><code class="language-rust">let numbers = vec![1, 2, 3, 4, 5];

let (sum, product, count) = numbers.iter()
    .fold((0, 1, 0), |(sum, prod, count), &amp;x| {
        (sum + x, prod * x, count + 1)
    });

let average = sum / count;
println!(&quot;Sum: {}, Product: {}, Count: {}, Avg: {}&quot;, 
    sum, product, count, average);
</code></pre>
<p><strong>Pattern 2: Struct accumulator</strong></p>
<pre><code class="language-rust">#[derive(Debug, Default)]
struct Statistics {
    count: usize,
    sum: i32,
    sum_squared: i32,
    min: i32,
    max: i32,
}

let stats = numbers.iter().fold(
    Statistics {
        min: i32::MAX,
        max: i32::MIN,
        ..Default::default()
    },
    |mut acc, &amp;x| {
        acc.count += 1;
        acc.sum += x;
        acc.sum_squared += x * x;
        acc.min = acc.min.min(x);
        acc.max = acc.max.max(x);
        acc
    }
);

let mean = stats.sum as f64 / stats.count as f64;
let variance = (stats.sum_squared as f64 / stats.count as f64) - mean * mean;
</code></pre>
<p><strong>Pattern 3: Multiple conditions</strong></p>
<pre><code class="language-rust">let (positives, negatives, zeros) = numbers.iter()
    .fold((0, 0, 0), |(pos, neg, zero), &amp;x| {
        match x {
            x if x &gt; 0 =&gt; (pos + 1, neg, zero),
            x if x &lt; 0 =&gt; (pos, neg + 1, zero),
            _ =&gt; (pos, neg, zero + 1),
        }
    });
</code></pre>
<p><strong>Pattern 4: Complex business logic</strong></p>
<pre><code class="language-rust">#[derive(Default)]
struct TransactionSummary {
    total_amount: f64,
    transaction_count: usize,
    high_value_count: usize,
    fees_collected: f64,
}

let summary = transactions.iter().fold(
    TransactionSummary::default(),
    |mut acc, tx| {
        acc.total_amount += tx.amount;
        acc.transaction_count += 1;
        if tx.amount &gt; 1000.0 {
            acc.high_value_count += 1;
        }
        acc.fees_collected += tx.fee;
        acc
    }
);
</code></pre>
<p><strong>Why single pass matters:</strong></p>
<pre><code class="language-rust">// Bad - four passes through data
let sum: i32 = data.iter().sum();
let count = data.iter().count();
let max = data.iter().max();
let min = data.iter().min();

// Good - one pass
let (sum, count, max, min) = data.iter().fold(
    (0, 0, i32::MIN, i32::MAX),
    |(sum, count, max, min), &amp;x| {
        (sum + x, count + 1, max.max(x), min.min(x))
    }
);
</code></pre>
<p><strong>Performance benefit:</strong> O(n) vs O(4n) - significant for large datasets.</p>
<p>Single-pass aggregation with fold is idiomatic and efficient Rust.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Consumer Chain Ending</h2>
<p>Why must consumers be at the end of an iterator chain? Can you chain after a consumer?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Consumers are terminal operations - they return values, not iterators, ending the chain.</p>
<p><strong>Can't chain after consumer:</strong></p>
<pre><code class="language-rust">// ERROR: consumers return values, not iterators
let result = data.iter()
    .filter(predicate)
    .sum()           // Returns i32
    .map(|x| x * 2); // Can't call .map() on i32!
</code></pre>
<p><strong>Why:</strong></p>
<pre><code class="language-rust">// Adaptor signature - returns Iterator
fn map&lt;F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt;
//                       ^^^^^^^^^^^^^^ Returns iterator

// Consumer signature - returns Value  
fn sum&lt;S&gt;(self) -&gt; S
//                 ^ Returns concrete type, not iterator
</code></pre>
<p><strong>Correct structure:</strong></p>
<pre><code class="language-rust">// Adaptors first, consumer last
let result: Vec&lt;_&gt; = data.iter()
    .filter(predicate)    // Adaptor → Iterator
    .map(transform)       // Adaptor → Iterator
    .take(10)            // Adaptor → Iterator
    .collect();          // CONSUMER → Vec
</code></pre>
<p><strong>Can't do this:</strong></p>
<pre><code class="language-rust">// ERROR: Can't continue after collecting
data.iter()
    .collect::&lt;Vec&lt;_&gt;&gt;()
    .iter()              // This needs a new iterator from Vec
    .map(|x| x * 2)
</code></pre>
<p><strong>Must restart from collection:</strong></p>
<pre><code class="language-rust">// Correct: collect, then create new iterator
let collected: Vec&lt;_&gt; = data.iter().collect();
let transformed: Vec&lt;_&gt; = collected.iter()
    .map(|x| x * 2)
    .collect();
</code></pre>
<p><strong>Multiple consumers require separate chains:</strong></p>
<pre><code class="language-rust">// Can't do: iter.sum().count() 

// Must do:
let sum: i32 = data.iter().sum();
let count = data.iter().count();
</code></pre>
<p><strong>Mental model:</strong></p>
<pre><code>Source → Adaptor → Adaptor → Adaptor → CONSUMER
  ↓         ↓         ↓         ↓          ↓
Iterator  Iterator  Iterator  Iterator   Value
                                          (END)
</code></pre>
<p><strong>Why this design:</strong>
- Consumers genuinely consume the iterator
- Return value is the final result
- No iterator state to continue from
- Forces clear, linear data flow</p>
<p>Consumers are exits, not waypoints.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Collect Pre Allocation</h2>
<p>How does <code>.collect()</code> optimize memory allocation? What is <code>size_hint()</code> and when does it help?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p><code>.collect()</code> uses <code>size_hint()</code> to pre-allocate the correct amount of memory when possible.</p>
<p><strong>Size hint mechanism:</strong></p>
<pre><code class="language-rust">pub trait Iterator {
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;)
    // Returns: (lower_bound, upper_bound)
}
</code></pre>
<p><strong>When size is known - efficient:</strong></p>
<pre><code class="language-rust">// Vec knows its size exactly
let vec = vec![1, 2, 3, 4, 5];
let collected: Vec&lt;_&gt; = vec.iter().collect();
// size_hint() returns (5, Some(5))
// .collect() pre-allocates exactly 5 elements
// No reallocation needed!
</code></pre>
<p><strong>When size is unknown - less efficient:</strong></p>
<pre><code class="language-rust">// Filter doesn't know final size
let collected: Vec&lt;_&gt; = vec.iter()
    .filter(|&amp;&amp;x| x % 2 == 0)
    .collect();
// size_hint() returns (0, Some(5))
// .collect() may need to reallocate as it grows
</code></pre>
<p><strong>Impact on performance:</strong></p>
<pre><code class="language-rust">// Known size - one allocation
(0..1000).collect::&lt;Vec&lt;_&gt;&gt;();
// Pre-allocates 1000 elements upfront

// Unknown size - multiple allocations
(0..1000)
    .filter(|x| some_condition(x))
    .collect::&lt;Vec&lt;_&gt;&gt;();
// Starts small, reallocates as needed (typically: 4, 8, 16, 32...)
</code></pre>
<p><strong>Adaptors that preserve size_hint:</strong>
- <code>.map()</code> - same size as source
- <code>.take(n)</code> - size is n
- <code>.enumerate()</code> - same size as source
- <code>.zip()</code> - size is minimum of both</p>
<p><strong>Adaptors that lose size_hint:</strong>
- <code>.filter()</code> - don't know how many pass
- <code>.flat_map()</code> - don't know expansion factor
- <code>.take_while()</code> - don't know when it stops</p>
<p><strong>Manual pre-allocation when you know size:</strong></p>
<pre><code class="language-rust">let mut vec = Vec::with_capacity(expected_size);
for item in iterator {
    vec.push(item);
}
</code></pre>
<p><strong>Checking size hint:</strong></p>
<pre><code class="language-rust">let iter = (0..100).filter(|x| x % 2 == 0);
let (lower, upper) = iter.size_hint();
println!(&quot;Will have at least {}, at most {:?}&quot;, lower, upper);
// Will have at least 0, at most Some(100)
</code></pre>
<p><strong>Why it matters:</strong>
- Reallocation is expensive (copy entire vector)
- Pre-allocation avoids this overhead
- Can be 2-10x faster for large collections
- Memory locality is better with single allocation</p>
<p>This optimization is transparent - <code>.collect()</code> does it automatically when possible.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Consumer Best Practices</h2>
<p>What are the key best practices when choosing and using iterator consumers?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Guidelines for effective and efficient consumer usage:</p>
<p><strong>1. Choose the right consumer for the job:</strong></p>
<pre><code class="language-rust">// Bad - over-collecting
if data.iter().collect::&lt;Vec&lt;_&gt;&gt;().len() &gt; 0 { }

// Good - use appropriate consumer
if data.iter().next().is_some() { }
</code></pre>
<p><strong>2. Prefer short-circuiting consumers:</strong></p>
<pre><code class="language-rust">// Less efficient - checks everything
let has_valid = data.iter()
    .filter(|x| x.is_valid())
    .count() &gt; 0;

// More efficient - stops early
let has_valid = data.iter().any(|x| x.is_valid());
</code></pre>
<p><strong>3. Avoid unnecessary allocation:</strong></p>
<pre><code class="language-rust">// Bad - unnecessary Vec
let sum = data.iter()
    .filter(predicate)
    .collect::&lt;Vec&lt;_&gt;&gt;()
    .iter()
    .sum();

// Good - direct sum
let sum: i32 = data.iter()
    .filter(predicate)
    .sum();
</code></pre>
<p><strong>4. Use fold for multiple aggregations:</strong></p>
<pre><code class="language-rust">// Bad - multiple passes
let sum: i32 = data.iter().sum();
let count = data.iter().count();

// Good - single pass
let (sum, count) = data.iter()
    .fold((0, 0), |(sum, count), &amp;x| (sum + x, count + 1));
</code></pre>
<p><strong>5. Collect once, reuse if needed:</strong></p>
<pre><code class="language-rust">// Bad - re-computing same iterator chain
let sum = expensive_chain().sum();
let max = expensive_chain().max();

// Good - compute once
let collected: Vec&lt;_&gt; = expensive_chain().collect();
let sum = collected.iter().sum();
let max = collected.iter().max();
</code></pre>
<p><strong>6. Provide type annotations clearly:</strong></p>
<pre><code class="language-rust">// Bad - unclear turbofish in middle
data.iter().filter(p).collect::&lt;Vec&lt;_&gt;&gt;()

// Good - type at declaration
let result: Vec&lt;_&gt; = data.iter().filter(p).collect();
</code></pre>
<p><strong>7. Use specialized consumers over fold:</strong></p>
<pre><code class="language-rust">// Verbose
let sum = data.iter().fold(0, |acc, &amp;x| acc + x);

// Clear
let sum: i32 = data.iter().sum();
</code></pre>
<p><strong>8. Handle errors appropriately:</strong></p>
<pre><code class="language-rust">// Consider if you want:
// - Stop at first error: use collect()
// - Separate errors: use partition()
// - Ignore errors: use filter_map()
</code></pre>
<p><strong>9. Don't forget the consumer:</strong></p>
<pre><code class="language-rust">// BUG - nothing happens!
data.iter().map(expensive_op);

// Fixed
data.iter().map(expensive_op).for_each(process);
</code></pre>
<p><strong>10. Consider performance characteristics:</strong></p>
<pre><code class="language-rust">// Slow on huge data
huge.iter().last();  // O(n)

// Fast
huge.last();  // O(1) if direct access available
</code></pre>
<p>Key principle: Match the consumer to what you actually need.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Consumer Anti Patterns</h2>
<p>What are common anti-patterns when using consumers? Show the mistake and correction for each.</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Common mistakes that hurt performance or clarity:</p>
<p><strong>Anti-pattern 1: Collect-then-length check</strong></p>
<pre><code class="language-rust">// ❌ Wrong - allocates unnecessarily
if data.iter().filter(p).collect::&lt;Vec&lt;_&gt;&gt;().is_empty() { }

// ✅ Right - no allocation
if data.iter().filter(p).next().is_none() { }
// or
if !data.iter().any(p) { }
</code></pre>
<p><strong>Anti-pattern 2: Unnecessary intermediate Vec</strong></p>
<pre><code class="language-rust">// ❌ Wrong - two allocations
let result: Vec&lt;_&gt; = data.iter()
    .map(|x| x * 2)
    .collect::&lt;Vec&lt;_&gt;&gt;()
    .iter()
    .filter(|&amp;&amp;x| x &gt; 10)
    .collect();

// ✅ Right - single allocation
let result: Vec&lt;_&gt; = data.iter()
    .map(|x| x * 2)
    .filter(|&amp;x| x &gt; 10)
    .collect();
</code></pre>
<p><strong>Anti-pattern 3: Multiple passes for aggregations</strong></p>
<pre><code class="language-rust">// ❌ Wrong - three passes through data
let sum: i32 = data.iter().sum();
let count = data.iter().count();
let avg = sum / count;

// ✅ Right - single pass
let (sum, count) = data.iter()
    .fold((0, 0), |(s, c), &amp;x| (s + x, c + 1));
let avg = sum / count;
</code></pre>
<p><strong>Anti-pattern 4: Collecting when you need count</strong></p>
<pre><code class="language-rust">// ❌ Wrong - allocates Vec just to count
let count = data.iter()
    .filter(p)
    .collect::&lt;Vec&lt;_&gt;&gt;()
    .len();

// ✅ Right - just counts
let count = data.iter()
    .filter(p)
    .count();
</code></pre>
<p><strong>Anti-pattern 5: Wrong consumer for boolean check</strong></p>
<pre><code class="language-rust">// ❌ Wrong - checks all elements
if data.iter().filter(|x| x.is_valid()).count() &gt; 0 { }

// ✅ Right - short-circuits
if data.iter().any(|x| x.is_valid()) { }
</code></pre>
<p><strong>Anti-pattern 6: Forgetting consumer entirely</strong></p>
<pre><code class="language-rust">// ❌ Wrong - does nothing!
data.iter()
    .map(|x| expensive_operation(x));

// ✅ Right - actually executes
data.iter()
    .map(|x| expensive_operation(x))
    .for_each(|result| process(result));
</code></pre>
<p><strong>Anti-pattern 7: Inefficient max/min</strong></p>
<pre><code class="language-rust">// ❌ Wrong - sorts entire collection
let max = data.iter()
    .copied()
    .collect::&lt;Vec&lt;_&gt;&gt;()
    .sort()
    .last();

// ✅ Right - single pass
let max = data.iter().max();
</code></pre>
<p><strong>Anti-pattern 8: Recreating same iterator</strong></p>
<pre><code class="language-rust">// ❌ Wrong - repeats expensive chain
fn process() {
    let x = expensive_chain().find(p1);
    let y = expensive_chain().find(p2);
    let z = expensive_chain().count();
}

// ✅ Right - compute once
fn process() {
    let collected: Vec&lt;_&gt; = expensive_chain().collect();
    let x = collected.iter().find(p1);
    let y = collected.iter().find(p2);
    let z = collected.len();
}
</code></pre>
<p><strong>Golden rule:</strong> Use the most specific consumer that solves your problem - avoid over-generalizing to collect().</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
            </div>
        </div>
        <div class="row">
            <div class="col ms-3">
                <button class="btn btn-dark btn-lg btn-outline-light w-100" type="button" data-bs-target="#carousel"
                    data-bs-slide="prev">
                    <!-- <span class="carousel-control-prev-icon" aria-hidden="true"></span> -->
                    <span class="">Previous</span>
                </button>
            </div>
            <div class="col me-3">
                <button class="btn btn-dark btn-lg btn-outline-light w-100" type="button" data-bs-target="#carousel"
                    data-bs-slide="next">
                    <!-- <span class="carousel-control-next-icon" aria-hidden="true"></span> -->
                    <span class="">Next</span>
                </button>
            </div>
        </div>
    </div>
</div>
<style>
    .flip-card {
        background-color: transparent;
        /* width: 200px; */
        height: 300px;
        /* border: 1px solid #f1f1f1; */
        /* perspective: 1000px; */
        /* Remove this if you don't want the 3D effect */
    }

    /* This container is needed to position the front and back side */
    .flip-card-inner {
        position: relative;
        width: 100%;
        height: 100%;
        /* text-align: center; */
        transition: transform 0.8s;
        transform-style: preserve-3d;
    }

    /* Do an horizontal flip when you move the mouse over the flip box container */
    /* .flip-card:hover .flip-card-inner {
        transform: rotateY(180deg);
    } */

    /* Position the front and back side */
    .flip-card-front,
    .flip-card-back {
        position: absolute;
        width: 100%;
        height: 100%;
        -webkit-backface-visibility: hidden;
        /* Safari */
        backface-visibility: hidden;
    }

    /* Style the front side (fallback if image is missing) */
    /* .flip-card-front {
        background-color: #bbb;
        color: black;
    } */

    /* Style the back side */
    .flip-card-back {
        /* background-color: dodgerblue;
        color: white; */
        transform: rotateY(180deg);
    }

    .vertical-center {
        margin: 0;
        position: absolute;
        top: 50%;
        -ms-transform: translateY(-50%);
        transform: translateY(-50%);
    }

    pre {
        white-space: pre-wrap;
    }

    .card-body {
        overflow: auto;
    }
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script>
    document.querySelector(".carousel-item").classList.add("active")
    const myCarouselElement = document.querySelector('#carousel')
    const carousel = new bootstrap.Carousel(myCarouselElement, {
        touch: true
    });
</script>
<script>
    hljs.highlightAll();

    document.addEventListener('DOMContentLoaded', (event) => {
        const flipCards = document.querySelectorAll('.flip-card');

        flipCards.forEach(flipCard => {
            const flipCardInner = flipCard.querySelector('.flip-card-inner');
            let isFlipped = false;

            flipCard.addEventListener('click', () => {
                if (isFlipped) {
                    flipCardInner.style.transform = 'rotateY(0deg)';
                } else {
                    flipCardInner.style.transform = 'rotateY(180deg)';
                }
                isFlipped = !isFlipped;
            });
        });
    });
</script>

      </div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.min.js"
    integrity="sha384-0pUGZvbkm6XF6gxjEnlmuGrJXVbNuzT9qBBavbLwCsOGabYfZo0T0to5eqruptLy"
    crossorigin="anonymous"></script>
</body>

</html>