<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="noindex, nofollow">
  <title>Flashcards - Rust - 06-Intermediate-Rust - 02-Traits-And-Generics - 04-Trait-Bounds</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
</head>

<body class="text-bg-dark">
  <div class="d-flex flex-column min-vh-100 min-vw-100">
    <div class="d-flex flex-grow-1 justify-content-center align-items-center">
      <div class="d-grid gap-2 col-12 mx-auto">
        
<div id="carousel" class="carousel slide">
    <div class="container">
        <div class="row">
            <!-- <div class="carousel-inner" style="width: 70%; margin-left: 15%;"> -->
            <div class="carousel-inner">

                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>What Are Trait Bounds?</h2>
<p>What is a trait bound and what is its purpose?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>A trait bound is a constraint on a generic type parameter that specifies which traits the type must implement. It tells the compiler: "This generic type T can be any type, but only if it has these specific capabilities."</p>
<pre><code class="language-rust">fn process&lt;T: Debug&gt;(value: T) {
    println!(&quot;{:?}&quot;, value);  // OK because T must implement Debug
}
</code></pre>
<p><strong>Purpose</strong>: Enable operations on generic types with compile-time guarantees.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Basic Trait Bound Syntax</h2>
<p>What is the syntax for adding a trait bound to a generic type parameter?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Use a colon after the type parameter followed by the trait name:</p>
<pre><code class="language-rust">fn function&lt;T: TraitName&gt;(param: T) {
    // T is constrained by TraitName
}

// Example:
fn debug_print&lt;T: Debug&gt;(value: T) {
    println!(&quot;{:?}&quot;, value);
}
</code></pre>
<p>The syntax <code>T: Debug</code> means "T is constrained by the Debug trait."</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Multiple Trait Bounds</h2>
<p>How do you specify that a generic type must implement multiple traits?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Use the <code>+</code> operator to combine multiple trait bounds:</p>
<pre><code class="language-rust">fn process&lt;T: Debug + Clone + PartialEq&gt;(value: T) {
    println!(&quot;{:?}&quot;, value);      // Uses Debug
    let copy = value.clone();     // Uses Clone
    assert!(value == copy);       // Uses PartialEq
}
</code></pre>
<p>All traits separated by <code>+</code> must be implemented by the type.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Where Clauses</h2>
<p>What are where clauses and when should you use them instead of inline trait bounds?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Where clauses place trait bounds after the function signature for better readability:</p>
<pre><code class="language-rust">// Inline (harder to read)
fn function&lt;T: Debug + Clone, U: Display + PartialEq&gt;(t: T, u: U) { }

// Where clause (cleaner)
fn function&lt;T, U&gt;(t: T, u: U)
where
    T: Debug + Clone,
    U: Display + PartialEq,
{
    // function body
}
</code></pre>
<p><strong>Use where clauses when</strong>:</p>
<ul>
<li>Multiple type parameters with bounds</li>
<li>Complex bounds (more than 2 traits)</li>
<li>Better readability is needed</li>
</ul>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Why Trait Bounds Are Necessary</h2>
<p>Why can't you use operations like printing or comparison on generic types without trait bounds?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>The compiler doesn't know what capabilities a generic type has. Without trait bounds, it can't guarantee the type supports the operations you want to use:</p>
<pre><code class="language-rust">// ❌ Doesn't work
fn print_and_compare&lt;T&gt;(a: T, b: T) {
    println!(&quot;{}&quot;, a);     // Error: T might not be printable
    if a &gt; b { }           // Error: T might not be comparable
}

// ✅ Works with bounds
fn print_and_compare&lt;T: Display + PartialOrd&gt;(a: T, b: T) {
    println!(&quot;{}&quot;, a);     // OK: T implements Display
    if a &gt; b { }           // OK: T implements PartialOrd
}
</code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Trait Bounds on Structs</h2>
<p>How do you add trait bounds when defining a generic struct?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Add bounds directly on the type parameter in the struct definition:</p>
<pre><code class="language-rust">struct Container&lt;T: Clone&gt; {
    value: T,
}

impl&lt;T: Clone&gt; Container&lt;T&gt; {
    fn new(value: T) -&gt; Self {
        Container { value }
    }

    fn duplicate(&amp;self) -&gt; T {
        self.value.clone()  // Can use .clone() because of bound
    }
}
</code></pre>
<p>The bound applies to all uses of the type parameter.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Conditional Implementation</h2>
<p>How can you provide different methods for a generic type based on what traits it implements?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Use multiple impl blocks with different trait bounds:</p>
<pre><code class="language-rust">struct Wrapper&lt;T&gt;(T);

// Methods available for ANY T
impl&lt;T&gt; Wrapper&lt;T&gt; {
    fn new(value: T) -&gt; Self {
        Wrapper(value)
    }
}

// Methods only when T implements Display
impl&lt;T: Display&gt; Wrapper&lt;T&gt; {
    fn print(&amp;self) {
        println!(&quot;{}&quot;, self.0);
    }
}

// Methods only when T implements Clone
impl&lt;T: Clone&gt; Wrapper&lt;T&gt; {
    fn duplicate(&amp;self) -&gt; T {
        self.0.clone()
    }
}
</code></pre>
<p>Types get different methods depending on their capabilities.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>impl Trait Syntax</h2>
<p>What is the <code>impl Trait</code> syntax and how does it differ from traditional trait bounds?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p><code>impl Trait</code> is a shorthand for simple trait bounds:</p>
<pre><code class="language-rust">// Traditional
fn process&lt;T: Display&gt;(value: T) { }

// impl Trait (shorter)
fn process(value: impl Display) { }
</code></pre>
<p><strong>Differences</strong>:</p>
<ul>
<li><code>impl Trait</code>: Simpler but you can't specify the concrete type</li>
<li>Traditional generic: Can use turbofish syntax <code>function::&lt;u8&gt;(value)</code></li>
</ul>
<p>They're almost equivalent for simple cases, but <code>impl Trait</code> has limitations with return types.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Common Trait Bound Mistake</h2>
<p>What error do you get if you try to use operations on a generic type without the proper trait bound?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>You get a compiler error saying the operation cannot be applied:</p>
<pre><code class="language-rust">fn compare&lt;T&gt;(a: T, b: T) -&gt; bool {
    a &gt; b  // ❌ Error: binary operation `&gt;` cannot be applied to type `T`
}
</code></pre>
<p><strong>Solution</strong>: Add the required trait bound:</p>
<pre><code class="language-rust">fn compare&lt;T: PartialOrd&gt;(a: T, b: T) -&gt; bool {
    a &gt; b  // ✅ Works: T implements PartialOrd
}
</code></pre>
<p>The error message usually tells you which trait is needed.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Debug vs Display Trait Bounds</h2>
<p>What's the difference between <code>Debug</code> and <code>Display</code> trait bounds, and how do you know which to use?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p><strong>Debug</strong> (<code>{:?}</code>): For programmer-facing output, debugging
<strong>Display</strong> (<code>{}</code>): For user-facing output, formatted display</p>
<pre><code class="language-rust">fn debug_print&lt;T: Debug&gt;(value: T) {
    println!(&quot;{:?}&quot;, value);  // Uses Debug
}

fn display_print&lt;T: Display&gt;(value: T) {
    println!(&quot;{}&quot;, value);    // Uses Display
}
</code></pre>
<p><strong>Rule</strong>: If you're using <code>{:?}</code>, you need <code>Debug</code>. If you're using <code>{}</code>, you need <code>Display</code>.</p>
<p>Most types implement <code>Debug</code> (often via <code>#[derive(Debug)]</code>), but fewer implement <code>Display</code>.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Supertrait Bounds</h2>
<p>What is a supertrait bound and how does it work?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>A supertrait bound means a trait requires another trait. Any type implementing the trait must also implement its supertrait:</p>
<pre><code class="language-rust">trait Printable: Display {  // Printable requires Display
    fn print_fancy(&amp;self) {
        println!(&quot;&gt;&gt;&gt; {} &lt;&lt;&lt;&quot;, self);  // Can use Display
    }
}

fn use_printable&lt;T: Printable&gt;(item: T) {
    // T automatically has Display because Printable requires it
    println!(&quot;{}&quot;, item);
    item.print_fancy();
}
</code></pre>
<p>The syntax <code>trait Printable: Display</code> means "to implement Printable, you must first implement Display."</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Overly Restrictive Bounds</h2>
<p>What's the problem with adding too many trait bounds, and how do you avoid it?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Overly restrictive bounds limit which types can use your function unnecessarily:</p>
<pre><code class="language-rust">// ❌ Too restrictive - only needs T to exist!
fn get_first&lt;T: Debug + Clone + Display&gt;(vec: Vec&lt;T&gt;) -&gt; Option&lt;T&gt; {
    vec.into_iter().next()
}

// ✅ Better - no unnecessary bounds
fn get_first&lt;T&gt;(vec: Vec&lt;T&gt;) -&gt; Option&lt;T&gt; {
    vec.into_iter().next()
}
</code></pre>
<p><strong>Rule</strong>: Only add trait bounds for operations you actually perform in the function. Don't add "just in case" bounds.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Trait Bounds with Lifetimes</h2>
<p>How do you combine lifetime parameters with trait bounds?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Lifetimes come first, then trait bounds with <code>where</code>:</p>
<pre><code class="language-rust">fn longest&lt;'a, T&gt;(x: &amp;'a T, y: &amp;'a T) -&gt; &amp;'a T
where
    T: PartialOrd,
{
    if x &gt; y { x } else { y }
}
</code></pre>
<p><strong>Pattern</strong>:</p>
<ol>
<li>Declare lifetime parameters: <code>&lt;'a&gt;</code></li>
<li>Declare type parameters: <code>&lt;'a, T&gt;</code></li>
<li>Add trait bounds: <code>where T: TraitName</code></li>
</ol>
<p>Lifetimes and trait bounds serve different purposes and work together.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Associated Type Constraints</h2>
<p>How do you constrain associated types in trait bounds?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Use the associated type syntax in the where clause:</p>
<pre><code class="language-rust">fn sum_iterator&lt;I&gt;(iter: I) -&gt; i32
where
    I: Iterator&lt;Item = i32&gt;,
{
    iter.sum()
}
</code></pre>
<p>This constrains the iterator's <code>Item</code> type to be <code>i32</code>.</p>
<p>Another example:</p>
<pre><code class="language-rust">fn process&lt;T&gt;(value: T)
where
    T: Iterator,
    T::Item: Display + Clone,
{
    // Iterator items must implement Display and Clone
}
</code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Marker Trait Bounds</h2>
<p>What are marker traits and how are they used in trait bounds?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Marker traits have no methods but provide compile-time guarantees. Common examples: <code>Send</code>, <code>Sync</code>, <code>Copy</code>.</p>
<pre><code class="language-rust">fn process&lt;T: Send + Sync&gt;(value: T) {
    // T can be safely sent between threads (Send)
    // T can be safely shared between threads (Sync)
}
</code></pre>
<p><strong>Send</strong>: Type can be transferred between threads
<strong>Sync</strong>: Type can be shared between threads via references
<strong>Copy</strong>: Type can be implicitly copied</p>
<p>Even with no methods, these traits tell the compiler about safety properties.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Trait Bounds Make Generics Useful</h2>
<p>Why are trait bounds essential for making generic types useful?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Without trait bounds, generic functions can't do anything with their parameters:</p>
<pre><code class="language-rust">// Useless - can't do ANYTHING with T
fn do_nothing&lt;T&gt;(value: T) {
    // Can't print, clone, compare, or use value at all!
}

// Useful - can perform operations
fn do_something&lt;T: Display + Clone&gt;(value: T) {
    println!(&quot;{}&quot;, value);     // Can print
    let copy = value.clone();  // Can clone
    // Now we can actually work with the value!
}
</code></pre>
<p>Trait bounds are what make generic programming practical by enabling operations on generic types.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Trait Bounds and Static Dispatch</h2>
<p>How do trait bounds relate to static dispatch and performance?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Trait bounds enable <strong>static dispatch</strong> (compile-time polymorphism), which has zero runtime cost:</p>
<pre><code class="language-rust">fn area&lt;T: Shape&gt;(shape: T) -&gt; f64 {
    shape.area()  // Compiler knows exact type at compile time
}
</code></pre>
<p>The compiler generates specialized code for each concrete type that calls the function. At runtime, there's no indirection or lookup—the exact method is called directly.</p>
<p>This is different from trait objects (<code>dyn Trait</code>) which use dynamic dispatch with a small runtime cost.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Reading Standard Library Signatures</h2>
<p>How does understanding trait bounds help you read standard library function signatures?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p>Standard library functions use trait bounds extensively. Understanding them helps you know what types you can pass:</p>
<pre><code class="language-rust">// From std library
pub fn max&lt;T: Ord&gt;(v1: T, v2: T) -&gt; T {
    if v1 &gt; v2 { v1 } else { v2 }
}
</code></pre>
<p>Reading this signature tells you:</p>
<ul>
<li><code>T</code> can be any type</li>
<li><code>T</code> must implement <code>Ord</code> (total ordering)</li>
<li>You can compare <code>T</code> values with <code>&gt;</code></li>
<li>Function returns the same type <code>T</code></li>
</ul>
<p>The trait bounds document the requirements clearly.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Inline vs Where Clause Decision</h2>
<p>When should you use inline trait bounds vs where clauses?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <p><strong>Use inline bounds</strong> for:</p>
<ul>
<li>Simple cases with one type parameter</li>
<li>Single trait bound</li>
<li>Short, readable signatures</li>
</ul>
<pre><code class="language-rust">fn simple&lt;T: Debug&gt;(value: T) { }
</code></pre>
<p><strong>Use where clauses</strong> for:</p>
<ul>
<li>Multiple type parameters</li>
<li>Multiple trait bounds per parameter</li>
<li>Associated type constraints</li>
<li>Better readability</li>
</ul>
<pre><code class="language-rust">fn complex&lt;T, U&gt;(t: T, u: U)
where
    T: Debug + Clone + Display,
    U: Iterator&lt;Item = i32&gt;,
{
    // Much more readable!
}
</code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="carousel-item">
                    <div class="flip-card m-3">
                        <div class="flip-card-inner">
                            <div class="flip-card-front">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <h2>Three Purposes of Trait Bounds</h2>
<p>What are the three key purposes of trait bounds?</p>
                                    </div>
                                </div>
                            </div>
                            <div class="flip-card-back">
                                <div class="card h-100 text-bg-dark border-light">
                                    <div class="card-body">
                                        <ol>
<li><strong>Enable operations</strong>: Let you call trait methods on generic types</li>
</ol>
<p><code>rust
   fn f&lt;T: Clone&gt;(x: T) { x.clone(); }  // Can call .clone()</code></p>
<ol>
<li><strong>Compile-time guarantees</strong>: Ensure types have required capabilities before code runs</li>
</ol>
<p><code>rust
   fn f&lt;T: Display&gt;(x: T) { println!("{}", x); }  // Guaranteed to work</code></p>
<ol>
<li><strong>Documentation</strong>: Make function requirements explicit and clear</li>
</ol>
<p><code>rust
   fn compare&lt;T: PartialOrd&gt;(a: T, b: T)  // Clear: T must be orderable</code></p>
<p>Trait bounds make generic code both safe and flexible.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
            </div>
        </div>
        <div class="row">
            <div class="col ms-3">
                <button class="btn btn-dark btn-lg btn-outline-light w-100" type="button" data-bs-target="#carousel"
                    data-bs-slide="prev">
                    <!-- <span class="carousel-control-prev-icon" aria-hidden="true"></span> -->
                    <span class="">Previous</span>
                </button>
            </div>
            <div class="col me-3">
                <button class="btn btn-dark btn-lg btn-outline-light w-100" type="button" data-bs-target="#carousel"
                    data-bs-slide="next">
                    <!-- <span class="carousel-control-next-icon" aria-hidden="true"></span> -->
                    <span class="">Next</span>
                </button>
            </div>
        </div>
    </div>
</div>
<style>
    .flip-card {
        background-color: transparent;
        /* width: 200px; */
        height: 300px;
        /* border: 1px solid #f1f1f1; */
        /* perspective: 1000px; */
        /* Remove this if you don't want the 3D effect */
    }

    /* This container is needed to position the front and back side */
    .flip-card-inner {
        position: relative;
        width: 100%;
        height: 100%;
        /* text-align: center; */
        transition: transform 0.8s;
        transform-style: preserve-3d;
    }

    /* Do an horizontal flip when you move the mouse over the flip box container */
    /* .flip-card:hover .flip-card-inner {
        transform: rotateY(180deg);
    } */

    /* Position the front and back side */
    .flip-card-front,
    .flip-card-back {
        position: absolute;
        width: 100%;
        height: 100%;
        -webkit-backface-visibility: hidden;
        /* Safari */
        backface-visibility: hidden;
    }

    /* Style the front side (fallback if image is missing) */
    /* .flip-card-front {
        background-color: #bbb;
        color: black;
    } */

    /* Style the back side */
    .flip-card-back {
        /* background-color: dodgerblue;
        color: white; */
        transform: rotateY(180deg);
    }

    .vertical-center {
        margin: 0;
        position: absolute;
        top: 50%;
        -ms-transform: translateY(-50%);
        transform: translateY(-50%);
    }

    pre {
        white-space: pre-wrap;
    }

    .card-body {
        overflow: auto;
    }
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script>
    document.querySelector(".carousel-item").classList.add("active")
    const myCarouselElement = document.querySelector('#carousel')
    const carousel = new bootstrap.Carousel(myCarouselElement, {
        touch: true
    });
</script>
<script>
    hljs.highlightAll();

    document.addEventListener('DOMContentLoaded', (event) => {
        const flipCards = document.querySelectorAll('.flip-card');

        flipCards.forEach(flipCard => {
            const flipCardInner = flipCard.querySelector('.flip-card-inner');
            let isFlipped = false;

            flipCard.addEventListener('click', () => {
                if (isFlipped) {
                    flipCardInner.style.transform = 'rotateY(0deg)';
                } else {
                    flipCardInner.style.transform = 'rotateY(180deg)';
                }
                isFlipped = !isFlipped;
            });
        });
    });
</script>

      </div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.min.js"
    integrity="sha384-0pUGZvbkm6XF6gxjEnlmuGrJXVbNuzT9qBBavbLwCsOGabYfZo0T0to5eqruptLy"
    crossorigin="anonymous"></script>
</body>

</html>